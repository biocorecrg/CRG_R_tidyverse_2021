# Handling missing values

* `tidyr::drop_na`: drop rows containing missing values.

Create a tibble that contains missing (NA) values:

```{r}
dfwithNA <- tibble(x = c(1, 2, NA, 5), 
                   y = c("a", NA, "b", "c"))

dfwithNA
```

Remove rows that contain NA values with `drop_na`:

```{r}
drop_na(dfwithNA)
```

* `tidyr::replace_na`: change NA values to a selected value (one per column):

```{r}
# replace NAs by 0s in column "x", and by "k" in column "y"
replace_na(dfwithNA, 
           list(x=0, y="k"))
```

* `tidyr::complete`: turns implicit missing values into explicit missing values:

```{r}
df <- tibble(
  patient = c("Patient1", "Patient1", "Patient2", "Patient3", "Patient3"),
  treatment = c("A", "B", "A", "A", "B"),
  value1 = 1:5,
  value2 = 4:8
)

# Missing a row for Patient2 / Treatment B: add it and fill in with NA values:
complete(df, patient, treatment)

# If you want to fill it missing other values that NA, you can use the fill parameter
complete(df, patient, treatment, 
         fill=list(value1=0, value2=NA))
```

* In practice: what if you have `NA` values, along with empty cells and "customized" missing values?

```{r}
dfwithNA2 <- tibble(x = c(1, 2, NA, 5, "", 4), 
          y = c("a", NA, "b", "c", "d", "missing"))
```

Replace empty cells and "customized" missing values with `NA` with `na_if`:

```{r}
dfwithNA2 %>% na_if("missing") %>% na_if("")
```

More complex solution: with `mutate` and `across`:

* `across`: apply the same transformation to multiple columns. It takes the following parameters:
  * `.fns`: function to apply to each of the selected columns.
  * `.cols`: columns to transform: by default, all columns will be transformed.
  
```{r}
# across: 
dfwithNA2 %>% mutate(across(.fns = ~replace(., . ==  "" | . == "missing", NA)))
```

**HANDS-ON**


