[["index.html", "Intermediate R: introduction to data wrangling with the Tidyverse (2021) Part 1 Welcome", " Intermediate R: introduction to data wrangling with the Tidyverse (2021) Sarah Bonnin 2021-04-13 Part 1 Welcome About the course The so-called tidyverse set of packages is widely used in the R community for powerful and efficient data reading, tidying, manipulation and visualization. It is one of the most popular and up-to-date set of tools for data analysis and data science using the R language. All tidyverse packages share a common vocabulary/grammar that makes code more intuitive and easier to read that the base R. This 8-hour training aims at introducing some of the tidyverse packages for data wrangling and manipulation: dplyr, tidyr, stringr and readr. Dates, time &amp; location Dates (2021): April 19th + 21rst Time: 9:30-13:30 Location: Online (Zoom: find details in the dedicated Moodle page) Instructors Sarah Bonnin Julia Ponomarenko from the CRG Bioinformatics core facility (office , 4th floor hospital side) Learning objectives Prerequisites This is an intermediate course. Familiarity with R scripting is required: syntax, installation of packages, objects manipulation, data import/export. Material All material is available from this page (https://biocorecrg.github.io/CRG_R_tidyverse_2021) and will be regularly updated. If you want to get the latest version locally, you can: download and uncompress the zip archive keep only the “docs” and \" images\" folders. open the “index.html” file in a web browser. Data import &amp; export: read_csv tibbles characteristics tidy data definition tidyr: separate &amp; unite count pivot (long and wide formats): pivot_longer, pivot_wider complete (missing values) “forward-pipe”: %&gt;% from the magrittr package stringr: str_remove str_length str_c (paste) str_sub dplyr: mutate, mutate_at, transmute select, select_if filter summarise, group_by arrange “join” functions "],["introduction.html", "Part 2 Introduction ", " Part 2 Introduction "],["what-is-the-tidyverse.html", "2.1 What is the “tidyverse”", " 2.1 What is the “tidyverse” A set of packages designed for data science: Preparing / cleaning Wrangling Visualizing All packages share good practices in terms of: Philosophy Grammar Data structure "],["good-reasons-to-learn-at-least-a-bit-how-to-use-it.html", "2.2 Good reasons to learn (at least a bit) how to use it", " 2.2 Good reasons to learn (at least a bit) how to use it More intuitive programming: the names of functions speak for themselves. The code is easier to read than with R base: it facilitates code sharing. More efficient: the functions are quite quick and you need to write less lines to get what you want. Very good documentation and tutorials. Here is a piece of R base code: diamonds2 &lt;- diamonds[diamonds$cut == &quot;Ideal&quot;, c(&quot;cut&quot;, &quot;color&quot;, &quot;carat&quot;, &quot;price&quot;)] diamonds2[order(diamonds2$price, decreasing=TRUE),] And its equivalent in the tidyverse: diamonds %&gt;% select(cut, color, carat, price) %&gt;% filter(cut==&quot;Ideal&quot;) %&gt;% arrange(desc(price)) "],["tidyverse-core-packages.html", "2.3 Tidyverse core packages", " 2.3 Tidyverse core packages The following 8 packages are included in the core tidyverse version 1.3.0.9000 (current version in April 2021): Data Wrangling and Transformation dplyr tidyr stringr forcats Data Import and Management tibble readr Functional Programming purrr Data Visualization and Exploration ggplot2 logo name description dplyr Package for data manipulation and exploratory data analysis. tidyr Package that aims at creating tidy data. Tidy data describe a standard way of storing data. stringr Package that provides a set of functions for user-friendly string manipulation. forcats Package that helps you deal with factors readr Package for fast and efficient import and export of data. tibble Tibbles are improved - easier to manage - data frames. purrr Package that aims at enhancing R’s functional programming toolkit. It provides a set of tools for working with functions and vectors. ggplot2 Package for data vizualization of graphics based on Leland Wilkinson’s’ Grammar of Graphics: graphics are built one layer at a time. "],["load-all-tidyverse-package.html", "2.4 Load all tidyverse package", " 2.4 Load all tidyverse package library(tidyverse) "],["tibbles.html", "Part 3 Tibbles ", " Part 3 Tibbles "],["what-are-tibbles.html", "3.1 What are tibbles?", " 3.1 What are tibbles? Modern re-thinking of data frame. They leave behind some features (sometimes user-unfriendly) of classical data frames: No string to factor conversion (NOTE: since version 4.0 of R, this is no longer the case for classical data frames) No automatic creation of row names. Column names can be non-valid R variable names (for example, they can start with numbers). You can create a simple tibble as you create a data frame, but with the tibble function: mytibble &lt;- tibble( letters = LETTERS, numbers = 1:26 ) mytibble Convert a data frame to a tibble: mydf &lt;- data.frame(letters = LETTERS, numbers = 1:26) as_tibble(mydf) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## # … with 16 more rows Convert a tibble to a data frame (useful to interact with R code that doesn’t support tibbles): as.data.frame(mytibble) ## letters numbers ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## 16 P 16 ## 17 Q 17 ## 18 R 18 ## 19 S 19 ## 20 T 20 ## 21 U 21 ## 22 V 22 ## 23 W 23 ## 24 X 24 ## 25 Y 25 ## 26 Z 26 "],["displaying-tibbles.html", "3.2 Displaying tibbles", " 3.2 Displaying tibbles The way it prints in the console is different that that of data frames: Dimensions are shown. Information about columns data types (no need for mode() or typeof). Only the first 10 rows are displayed. Only the columns that fit the screen are displayed. If you want to see more rows, set the n parameter in print(): Print the first 15 rows: print(mytibble, n=15) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## # … with 11 more rows Print all rows: print(mytibble, n=Inf) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## 16 P 16 ## 17 Q 17 ## 18 R 18 ## 19 S 19 ## 20 T 20 ## 21 U 21 ## 22 V 22 ## 23 W 23 ## 24 X 24 ## 25 Y 25 ## 26 Z 26 "],["subsetting-manipulating-tibbles.html", "3.3 Subsetting / manipulating tibbles", " 3.3 Subsetting / manipulating tibbles Extract column by name: # with the $ mytibble$letters ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; ## [25] &quot;Y&quot; &quot;Z&quot; # or the [[]] mytibble[[&quot;letters&quot;]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; ## [25] &quot;Y&quot; &quot;Z&quot; # Note: with using simple square brackets, you extract a sub-tibble (2 dimensions) mytibble[&quot;letters&quot;] ## # A tibble: 26 x 1 ## letters ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## 7 G ## 8 H ## 9 I ## 10 J ## # … with 16 more rows Extract column by position/index: mytibble ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## # … with 16 more rows HANDS-ON Answer "],["tidy-data-with-tidyr.html", "Part 4 Tidy data with tidyr ", " Part 4 Tidy data with tidyr "],["what-is-tidy-data.html", "4.1 What is “tidy” data?", " 4.1 What is “tidy” data? Tidy data is where: Each column describes a variable. Each row describes an observation. Each value is a cell. Example of a tidy data: day month year weight height 12 4 2020 3.5 48 23 8 2019 2.9 50 9 11 2020 3.8 50 Example of untidy data: day month,year weight height 12 4,2020 3.5kg 48 23 8,2019 2.9kg 50 9 11,2020 3.8kg 50 Here we introduce some useful functions from the tidyr package to clean up and organize data so that to obtain tidy data that can then be processed more easily: 4.1.1 Separate &amp; Unite Let’s work on this untidy tibble table5 that is a built-in data set from the tidyr package (table5 displays the number of tuberculosis cases documented by the WHO in selected countries): table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 4.1.1.1 Separate Function separate separates (indeed!) a column into 2 or more columns: separate(data, col, into, sep) # separate column &quot;rate&quot; into 2 columns that we name cases and population, based on the &quot;/&quot; separator. table5_1 &lt;- separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot; ) table5_1 ## # A tibble: 6 x 5 ## country century year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745 19987071 ## 2 Afghanistan 20 00 2666 20595360 ## 3 Brazil 19 99 37737 172006362 ## 4 Brazil 20 00 80488 174504898 ## 5 China 19 99 212258 1272915272 ## 6 China 20 00 213766 1280428583 4.1.1.2 Unite Function unite does just the opposite: it will unite/stick together 2 or (more) columns: unite(data, col, *column names*, sep). # unite columns &quot;century&quot; and &quot;year&quot; table5a_2 &lt;- unite(data=table5_1, col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) table5a_2 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 HANDS-ON Fix the following untidy tibble: patients &lt;- tibble( ID1=c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), ID2=c(12, 13, 14, 15), age=c( 21, 32, 25, 43), c(&quot;188_93&quot;, &quot;167_55&quot;, &quot;155_51&quot;, &quot;175_72&quot;) ) Separate the two variables that are found in the last column into columns height and weight. Unite columns ID1 and ID2 so as to create a unique ID per patient. Answer # Separate the two variables that are found in the last column. patients2 &lt;- separate(data=patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) # Unite columns ID1 and ID2 so as to create a unique ID per patient. patients3 &lt;- unite(data=patients2, col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) Is there a problem with patients3? Columns height and weight are treated as characters (because they contained characters “kg” and “cm”). We can convert them into numbers with the mutate_at function from the dplyr package: # first argument: the tibble # second argument: a vector of column names to mutate # third argument: how to mutate those columns patients4 &lt;- mutate_at(patients3, c(&quot;height&quot;, &quot;weight&quot;), as.numeric) "],["the-forward-pipe-operator.html", "Part 5 The %&gt;% forward-pipe operator", " Part 5 The %&gt;% forward-pipe operator Let’s review the steps from the previous hands-on: patients2 &lt;- separate(data=patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) patients3 &lt;- unite(data=patients2, col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) patients4 &lt;- mutate_at(patients3, c(&quot;height&quot;, &quot;weight&quot;), as.numeric) If we are only interested in the final tidy data frame, there is a simpler and cleaner way: the %&gt;% (forward-pipe) operator from the magritrrr package (the tidyverse packages automatically load this operator). Allows to process the output of a function as the input of the following function: it makes the code easier to read and understand: It pipes the output of a function as the first argument of the next function (from left to right): mytibble %&gt;% function1 is equivalent to function1(mytibble) mytibble %&gt;% function2(y) is equivalent to function1(mytibble, y) mytibble %&gt;% function1 %&gt;% function2 is equivalent to function2(function1(mytibble)) If we go back to the previous exercise, we can simplify the code the following way: patients2 &lt;- patients %&gt;% separate(col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) %&gt;% unite(col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) %&gt;% mutate_at(c(&quot;height&quot;, &quot;weight&quot;), as.numeric) HANDS-ON Simplify the following piece of code using the %&gt;% operator: table5_1 &lt;- separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) table5_2 &lt;- unite(data=table5_1, col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) Answer table5_1 &lt;- table5 %&gt;% separate(col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) %&gt;% unite(col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) "],["input-output-with-readr.html", "Part 6 Input / output with readr ", " Part 6 Input / output with readr "],["read.html", "6.1 Read", " 6.1 Read read_delim, read_csv, read_tsv: Read a delimited file into a tibble: Table 6.1: read_delim and derived functions name delim read_delim needs to be set read_csv ,: comma-separated read_tsv : tab-separated read_table: Read whitespace-separated columns into a tibble read_file (and read_file_raw): reads into a character vector of length one (or raw vector) "],["write.html", "6.2 Write", " 6.2 Write format_csv format_tsv write_delim write_csv write_tsv "],["data-manipulation.html", "Part 7 Data manipulation", " Part 7 Data manipulation Package dplyr dntroduces a grammar of data manipulation. Cheat sheet We will introduce the 5 intuitively-named key functions from {dplyr}: mutate() adds new variables (columns) that are functions of existing variables select() picks variables (columns) based on their names. filter() picks observations (rows) based on their values. summarise() collapses multiple values down to a single summary. arrange() changes the ordering of the rows. All 5 functions work in a similar and consistent way: The first argument is a data frame or a tibble. The result is a new data frame. Note that {dplyr} never modifies the input: you need to redirect the output and save in a new - or the same - object. We will use the presidential data set. It contains data of the terms of presidents of the USA, from Eisenhower to Obama: Name Term starting date Term ending date of mandate Political party print(presidential, n=6) ## # A tibble: 11 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 4 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 5 Ford 1974-08-09 1977-01-20 Republican 895 days ## 6 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## # … with 5 more rows "],["mutate-transmute.html", "7.1 mutate &amp; transmute", " 7.1 mutate &amp; transmute mutate allows to create new columns that are functions of the existing ones. Create a new column with the duration of each term: # Subtracting column start to colum end mutate(presidential, duration_days=end - start) Notes: Use unquoted column names. Columns are added at the end of the data frame. mutate keeps all columns. If you want to keep only the newly created column(s) (drop the remaining ones): use transmute() instead of mutate(): transmute(presidential, duration_days=end - start) Re-assign to a new - or the same - data frame/tibble using the R assignment operator: &lt;- presidential &lt;- mutate(presidential, duration_days=end - start) "],["select.html", "7.2 select", " 7.2 select select will select (and optionally rename) columns/variables in a data frame / tibble. Select column name only from the presidential data set: name start end party duration_days Eisenhower 1953-01-20 1961-01-20 Republican 2922 days Kennedy 1961-01-20 1963-11-22 Democratic 1036 days Johnson 1963-11-22 1969-01-20 Democratic 1886 days Nixon 1969-01-20 1974-08-09 Republican 2027 days Ford 1974-08-09 1977-01-20 Republican 895 days Carter 1977-01-20 1981-01-20 Democratic 1461 days Reagan 1981-01-20 1989-01-20 Republican 2922 days Bush 1989-01-20 1993-01-20 Republican 1461 days Clinton 1993-01-20 2001-01-20 Democratic 2922 days Bush 2001-01-20 2009-01-20 Republican 2922 days Obama 2009-01-20 2017-01-20 Democratic 2922 days select(presidential, name) ## # A tibble: 11 x 1 ## name ## &lt;chr&gt; ## 1 Eisenhower ## 2 Kennedy ## 3 Johnson ## 4 Nixon ## 5 Ford ## 6 Carter ## 7 Reagan ## 8 Bush ## 9 Clinton ## 10 Bush ## 11 Obama Select 2 columns: party and name (in that order): select(presidential, party, name) Rename a column as you select it: select(presidential, party, President=name) ## # A tibble: 11 x 2 ## party President ## &lt;chr&gt; &lt;chr&gt; ## 1 Republican Eisenhower ## 2 Democratic Kennedy ## 3 Democratic Johnson ## 4 Republican Nixon ## 5 Republican Ford ## 6 Democratic Carter ## 7 Republican Reagan ## 8 Republican Bush ## 9 Democratic Clinton ## 10 Republican Bush ## 11 Democratic Obama Select all columns except party with the - sign: select(presidential, -party) ## # A tibble: 11 x 4 ## name start end duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;drtn&gt; ## 1 Eisenhower 1953-01-20 1961-01-20 2922 days ## 2 Kennedy 1961-01-20 1963-11-22 1036 days ## 3 Johnson 1963-11-22 1969-01-20 1886 days ## 4 Nixon 1969-01-20 1974-08-09 2027 days ## 5 Ford 1974-08-09 1977-01-20 895 days ## 6 Carter 1977-01-20 1981-01-20 1461 days ## 7 Reagan 1981-01-20 1989-01-20 2922 days ## 8 Bush 1989-01-20 1993-01-20 1461 days ## 9 Clinton 1993-01-20 2001-01-20 2922 days ## 10 Bush 2001-01-20 2009-01-20 2922 days ## 11 Obama 2009-01-20 2017-01-20 2922 days Select all columns between start and party (with both included) select(presidential, start:party) ## # A tibble: 11 x 3 ## start end party ## &lt;date&gt; &lt;date&gt; &lt;chr&gt; ## 1 1953-01-20 1961-01-20 Republican ## 2 1961-01-20 1963-11-22 Democratic ## 3 1963-11-22 1969-01-20 Democratic ## 4 1969-01-20 1974-08-09 Republican ## 5 1974-08-09 1977-01-20 Republican ## 6 1977-01-20 1981-01-20 Democratic ## 7 1981-01-20 1989-01-20 Republican ## 8 1989-01-20 1993-01-20 Republican ## 9 1993-01-20 2001-01-20 Democratic ## 10 2001-01-20 2009-01-20 Republican ## 11 2009-01-20 2017-01-20 Democratic 7.2.1 select_if Select only columns containing characters with select_if(): select_if(presidential, is.character) #&lt;&lt; ## # A tibble: 11 x 2 ## name party ## &lt;chr&gt; &lt;chr&gt; ## 1 Eisenhower Republican ## 2 Kennedy Democratic ## 3 Johnson Democratic ## 4 Nixon Republican ## 5 Ford Republican ## 6 Carter Democratic ## 7 Reagan Republican ## 8 Bush Republican ## 9 Clinton Democratic ## 10 Bush Republican ## 11 Obama Democratic Select only columns containing a date: "],["filter.html", "7.3 filter", " 7.3 filter filter() is used to filter rows in a data frame / tibble. Keep rows if party is Democratic: name start end party duration_days Eisenhower 1953-01-20 1961-01-20 Republican 2922 days Kennedy 1961-01-20 1963-11-22 Democratic 1036 days Johnson 1963-11-22 1969-01-20 Democratic 1886 days Nixon 1969-01-20 1974-08-09 Republican 2027 days Ford 1974-08-09 1977-01-20 Republican 895 days Carter 1977-01-20 1981-01-20 Democratic 1461 days Reagan 1981-01-20 1989-01-20 Republican 2922 days Bush 1989-01-20 1993-01-20 Republican 1461 days Clinton 1993-01-20 2001-01-20 Democratic 2922 days Bush 2001-01-20 2009-01-20 Republican 2922 days Obama 2009-01-20 2017-01-20 Democratic 2922 days filter(presidential, party==&quot;Democratic&quot;) ## # A tibble: 5 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 2 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 3 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 4 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 5 Obama 2009-01-20 2017-01-20 Democratic 2922 days You can filter using several variables/columns: filter(presidential, party==&quot;Republican&quot;, name==&quot;Bush&quot;) # This implicity uses the &quot;&amp;&quot;, i.e. the fact that both conditions have to be TRUE filter(presidential, party==&quot;Republican&quot; &amp; name==&quot;Bush&quot;) # Any logical operators can be used filter(presidential, name %in% c(&quot;Bush&quot;, &quot;Kennedy&quot;)) "],["summarise-group-by.html", "7.4 summarise &amp; group_by", " 7.4 summarise &amp; group_by summarise collapses a data frame to a single row (base R: aggregate()) Get average length of terms: summarise(presidential, mean(duration_days)) ## # A tibble: 1 x 1 ## `mean(duration_days)` ## &lt;drtn&gt; ## 1 2125.091 days Get average length of terms + count of the total of entries: summarise(presidential, mean(duration_days), n()) ## # A tibble: 1 x 2 ## `mean(duration_days)` `n()` ## &lt;drtn&gt; &lt;int&gt; ## 1 2125.091 days 11 You can combine summarise with group_by to get the average length of terms per political party: group_by defines a grouping based on existing variables. summarise then processes the command based on the grouping groups &lt;- group_by(presidential, party) summarise(groups, mean(duration_days), n()) ## # A tibble: 2 x 3 ## party `mean(duration_days)` `n()` ## * &lt;chr&gt; &lt;drtn&gt; &lt;int&gt; ## 1 Democratic 2045.4 days 5 ## 2 Republican 2191.5 days 6 # One line, using the %&gt;% operator: group_by(presidential, party) %&gt;% summarise(mean(duration_days), n()) ## # A tibble: 2 x 3 ## party `mean(duration_days)` `n()` ## * &lt;chr&gt; &lt;drtn&gt; &lt;int&gt; ## 1 Democratic 2045.4 days 5 ## 2 Republican 2191.5 days 6 "],["arrange.html", "7.5 arrange", " 7.5 arrange arrange orders the rows of a data frame by the values of selected columns. Let’s order rows by increasing mandate duration: arrange(presidential, duration_days) ## # A tibble: 11 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Ford 1974-08-09 1977-01-20 Republican 895 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 4 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 5 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 6 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 7 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 8 Reagan 1981-01-20 1989-01-20 Republican 2922 days ## 9 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 10 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 11 Obama 2009-01-20 2017-01-20 Democratic 2922 days # decreasing order: arrange(presidential2, desc(duration_days)) You can use several columns for the sorting arrange(presidential, duration_days, name) ## # A tibble: 11 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Ford 1974-08-09 1977-01-20 Republican 895 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 4 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 5 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 6 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 7 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 8 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 9 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 10 Obama 2009-01-20 2017-01-20 Democratic 2922 days ## 11 Reagan 1981-01-20 1989-01-20 Republican 2922 days If a grouping was done before, you can arrange first by grouping and then by selected variable(s) setting the .by_group=TRUE parameter: mutate(presidential, duration_days=end-start) %&gt;% group_by(party) %&gt;% arrange(duration_days, .by_group=TRUE) HANDS ON mutate(presidential, duration_days=end-start) %&gt;% filter(party == &quot;Democratic&quot;) %&gt;% summarise(mean(duration_days)) ## # A tibble: 1 x 1 ## `mean(duration_days)` ## &lt;drtn&gt; ## 1 2045.4 days mutate(presidential, duration_days=end-start) %&gt;% group_by(party) %&gt;% summarise(mean(duration_days)) ## # A tibble: 2 x 2 ## party `mean(duration_days)` ## * &lt;chr&gt; &lt;drtn&gt; ## 1 Democratic 2045.4 days ## 2 Republican 2191.5 days We will work with the storms data set: * Positions and attributes of 198 tropical storms, measured every 6 hours Remove columns month, day, hour, lat, long, ts_diameter and hu_diameter. Calculate the median pressure for each storm status. Calculate the minimum wind speed for each storm (name). What storm has the minimum wind speed? Calculate how many storms happened each year. TIP: find what distinct() from {dplyr} can do… What are the years with the maximum number of storms? Remove columns month, day, hour, lat, long, ts_diameter and hu_diameter. * Calculate the median pressure for each storm status. # remove columns select(storms, -lat, -long, -ts_diameter, -hu_diameter) # same as: select(storms, -c(lat, long, ts_diameter, hu_diameter)) # group by status and calculate median pressure per storm status select(storms, -lat, -long, -ts_diameter, -hu_diameter) %&gt;% group_by(status) %&gt;% summarise(median(pressure)) ## # A tibble: 3 x 2 ## status `median(pressure)` ## * &lt;chr&gt; &lt;dbl&gt; ## 1 hurricane 973 ## 2 tropical depression 1008 ## 3 tropical storm 1000 Calculate the minimum wind speed for each storm (name). * What storm has the smallest minimum wind speed? # group storms by name and calculate minimum wind speed storms %&gt;% group_by(name) %&gt;% summarise(min_wind = min(wind)) Calculate the minimum wind speed for each storm (name). * What storm has the smallest minimum wind speed? # sort by increasing minimum wind speed storms %&gt;% group_by(name) %&gt;% summarise(min_wind = min(wind)) %&gt;% arrange(min_wind) ## # A tibble: 198 x 2 ## name min_wind ## &lt;chr&gt; &lt;int&gt; ## 1 AL031987 10 ## 2 Alberto 10 ## 3 Bonnie 10 ## 4 AL021994 15 ## 5 AL072003 15 ## 6 Allison 15 ## 7 Barry 15 ## 8 Beryl 15 ## 9 Claudette 15 ## 10 Fay 15 ## # … with 188 more rows Calculate how many storms happened each year. TIP: find what distinct() from {dplyr} can do… What are the years with the maximum number of storms? # get unique rows when considering both name and year columns distinct(storms, name, year) # group by year and count the number of storms distinct(storms, name, year) %&gt;% group_by(year) %&gt;% summarise(storms_per_year=n()) # sort by decreasing number of storms distinct(storms, name, year) %&gt;% group_by(year) %&gt;% summarise(storms_per_year=n()) %&gt;% arrange(desc(storms_per_year)) ## # A tibble: 41 x 2 ## year storms_per_year ## &lt;dbl&gt; &lt;int&gt; ## 1 1995 21 ## 2 2005 21 ## 3 2003 20 ## 4 2010 20 ## 5 2001 17 ## 6 2012 17 ## 7 2000 16 ## 8 2007 16 ## 9 2011 15 ## 10 2008 14 ## # … with 31 more rows nth(): extract the nth value of a vector presidential %&gt;% nth(name, 4) extract a single column: presidential %&gt;% pull(name) presidential %&gt;% pull(duration_days, name=name) subset rows using their positions: presidential %&gt;% slice(4) "]]
