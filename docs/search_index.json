[["index.html", "Intermediate R: introduction to data wrangling with the Tidyverse (2021) Part 1 Welcome", " Intermediate R: introduction to data wrangling with the Tidyverse (2021) Sarah Bonnin 2021-04-12 Part 1 Welcome About the course The so-called tidyverse set of packages is widely used in the R community for powerful and efficient data reading, tidying, manipulation and visualization. It is one of the most popular and up-to-date set of tools for data analysis and data science using the R language. All tidyverse packages share a common vocabulary/grammar that makes code more intuitive and easier to read that the base R. This 8-hour training aims at introducing some of the tidyverse packages for data wrangling and manipulation: dplyr, tidyr, stringr and readr. Dates, time &amp; location Dates (2021): April 19th + 21rst Time: 9:30-13:30 Location: Online (Zoom: find details in the dedicated Moodle page) Instructors Sarah Bonnin Julia Ponomarenko from the CRG Bioinformatics core facility (office , 4th floor hospital side) Learning objectives Prerequisites This is an intermediate course. Familiarity with R scripting is required: syntax, installation of packages, objects manipulation, data import/export. Material All material is available from this page (https://biocorecrg.github.io/CRG_R_tidyverse_2021) and will be regularly updated. If you want to get the latest version locally, you can: download and uncompress the zip archive keep only the “docs” and \" images\" folders. open the “index.html” file in a web browser. Data import &amp; export: read_csv tibbles characteristics tidy data definition tidyr: separate &amp; unite count pivot (long and wide formats): pivot_longer, pivot_wider complete (missing values) “forward-pipe”: %&gt;% from the magrittr package stringr: str_remove str_length str_c (paste) str_sub dplyr: mutate, mutate_at, transmute select, select_if filter summarise, group_by arrange “join” functions "],["introduction.html", "Part 2 Introduction ", " Part 2 Introduction "],["what-is-the-tidyverse.html", "2.1 What is the “tidyverse”", " 2.1 What is the “tidyverse” A set of packages designed for data science: Preparing / cleaning Wrangling Visualizing All packages share good practices in terms of: Philosophy Grammar Data structure "],["good-reasons-to-learn-at-least-a-bit-how-to-use-it.html", "2.2 Good reasons to learn (at least a bit) how to use it", " 2.2 Good reasons to learn (at least a bit) how to use it More intuitive programming: the names of functions speak for themselves. The code is easier to read than with R base: it facilitates code sharing. More efficient: the functions are quite quick and you need to write less lines to get what you want. Very good documentation and tutorials. Here is a piece of R base code: diamonds2 &lt;- diamonds[diamonds$cut == &quot;Ideal&quot;, c(&quot;cut&quot;, &quot;color&quot;, &quot;carat&quot;, &quot;price&quot;)] diamonds2[order(diamonds2$price, decreasing=TRUE),] And its equivalent in the tidyverse: diamonds %&gt;% select(cut, color, carat, price) %&gt;% filter(cut==&quot;Ideal&quot;) %&gt;% arrange(desc(price)) "],["tidyverse-core-packages.html", "2.3 Tidyverse core packages", " 2.3 Tidyverse core packages The following 8 packages are included in the core tidyverse version 1.3.0.9000 (current version in April 2021): Data Wrangling and Transformation dplyr tidyr stringr forcats Data Import and Management tibble readr Functional Programming purrr Data Visualization and Exploration ggplot2 logo name description dplyr Package for data manipulation and exploratory data analysis. tidyr Package that aims at creating tidy data. Tidy data describe a standard way of storing data. stringr Package that provides a set of functions for user-friendly string manipulation. forcats Package that helps you deal with factors readr Package for fast and efficient import and export of data. tibble Tibbles are improved - easier to manage - data frames. purrr Package that aims at enhancing R’s functional programming toolkit. It provides a set of tools for working with functions and vectors. ggplot2 Package for data vizualization of graphics based on Leland Wilkinson’s’ Grammar of Graphics: graphics are built one layer at a time. "],["load-all-tidyverse-package.html", "2.4 Load all tidyverse package", " 2.4 Load all tidyverse package library(tidyverse) "],["tibbles.html", "Part 3 Tibbles ", " Part 3 Tibbles "],["what-are-tibbles.html", "3.1 What are tibbles?", " 3.1 What are tibbles? Modern re-thinking of data frame. They leave behind some features (sometimes user-unfriendly) of classical data frames: No string to factor conversion (NOTE: since version 4.0 of R, this is no longer the case for classical data frames) No automatic creation of row names. Column names can be non-valid R variable names (for example, they can start with numbers). You can create a simple tibble as you create a data frame, but with the tibble function: mytibble &lt;- tibble( letters = LETTERS, numbers = 1:26 ) mytibble Convert a data frame to a tibble: mydf &lt;- data.frame(letters = LETTERS, numbers = 1:26) as_tibble(mydf) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## # … with 16 more rows Convert a tibble to a data frame (useful to interact with R code that doesn’t support tibbles): as.data.frame(mytibble) ## letters numbers ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## 16 P 16 ## 17 Q 17 ## 18 R 18 ## 19 S 19 ## 20 T 20 ## 21 U 21 ## 22 V 22 ## 23 W 23 ## 24 X 24 ## 25 Y 25 ## 26 Z 26 "],["displaying-tibbles.html", "3.2 Displaying tibbles", " 3.2 Displaying tibbles The way it prints in the console is different that that of data frames: Dimensions are shown. Information about columns data types (no need for mode() or typeof). Only the first 10 rows are displayed. Only the columns that fit the screen are displayed. If you want to see more rows, set the n parameter in print(): Print the first 15 rows: print(mytibble, n=15) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## # … with 11 more rows Print all rows: print(mytibble, n=Inf) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## 16 P 16 ## 17 Q 17 ## 18 R 18 ## 19 S 19 ## 20 T 20 ## 21 U 21 ## 22 V 22 ## 23 W 23 ## 24 X 24 ## 25 Y 25 ## 26 Z 26 "],["subsetting-manipulating-tibbles.html", "3.3 Subsetting / manipulating tibbles", " 3.3 Subsetting / manipulating tibbles Extract column by name: # with the $ mytibble$letters ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; ## [25] &quot;Y&quot; &quot;Z&quot; # or the [[]] mytibble[[&quot;letters&quot;]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; ## [25] &quot;Y&quot; &quot;Z&quot; # Note: with using simple square brackets, you extract a sub-tibble (2 dimensions) mytibble[&quot;letters&quot;] ## # A tibble: 26 x 1 ## letters ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## 7 G ## 8 H ## 9 I ## 10 J ## # … with 16 more rows Extract column by position/index: mytibble ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## # … with 16 more rows HANDS-ON Answer "],["tidy-data-with-tidyr.html", "Part 4 Tidy data with tidyr ", " Part 4 Tidy data with tidyr "],["what-is-tidy-data.html", "4.1 What is “tidy” data?", " 4.1 What is “tidy” data? Tidy data is where: Each column describes a variable. Each row describes an observation. Each value is a cell. Example of a tidy data: day month year weight height 12 4 2020 3.5 48 23 8 2019 2.9 50 9 11 2020 3.8 50 Example of untidy data: day month,year weight height 12 4,2020 3.5kg 48 23 8,2019 2.9kg 50 9 11,2020 3.8kg 50 Here we introduce some useful functions from the tidyr package to clean up and organize data so that to obtain tidy data that can then be processed more easily: 4.1.1 Separate &amp; Unite Let’s work on this untidy tibble table5 that is a built-in data set from the tidyr package (table5 displays the number of tuberculosis cases documented by the WHO in selected countries): table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 4.1.1.1 Separate Function separate separates (indeed!) a column into 2 or more columns: separate(data, col, into, sep) # separate column &quot;rate&quot; into 2 columns that we name cases and population, based on the &quot;/&quot; separator. table5_1 &lt;- separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot; ) table5_1 ## # A tibble: 6 x 5 ## country century year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745 19987071 ## 2 Afghanistan 20 00 2666 20595360 ## 3 Brazil 19 99 37737 172006362 ## 4 Brazil 20 00 80488 174504898 ## 5 China 19 99 212258 1272915272 ## 6 China 20 00 213766 1280428583 4.1.1.2 Unite Function unite does just the opposite: it will unite/stick together 2 or (more) columns: unite(data, col, *column names*, sep). # unite columns &quot;century&quot; and &quot;year&quot; table5a_2 &lt;- unite(data=table5_1, col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) table5a_2 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 HANDS-ON Fix the following untidy tibble: patients &lt;- tibble( ID1=c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), ID2=c(12, 13, 14, 15), age=c( 21, 32, 25, 43), c(&quot;188_93&quot;, &quot;167_55&quot;, &quot;155_51&quot;, &quot;175_72&quot;) ) Separate the two variables that are found in the last column into columns height and weight. Unite columns ID1 and ID2 so as to create a unique ID per patient. Answer # Separate the two variables that are found in the last column. patients2 &lt;- separate(data=patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) # Unite columns ID1 and ID2 so as to create a unique ID per patient. patients3 &lt;- unite(data=patients2, col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) Is there a problem with patients3? Columns height and weight are treated as characters (because they contained characters “kg” and “cm”). We can convert them into numbers with the mutate_at function from the dplyr package: # first argument: the tibble # second argument: a vector of column names to mutate # third argument: how to mutate those columns patients4 &lt;- mutate_at(patients3, c(&quot;height&quot;, &quot;weight&quot;), as.numeric) "],["the-forward-pipe-operator.html", "Part 5 The %&gt;% forward-pipe operator", " Part 5 The %&gt;% forward-pipe operator Let’s review the steps from the previous hands-on: patients2 &lt;- separate(data=patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) patients3 &lt;- unite(data=patients2, col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) patients4 &lt;- mutate_at(patients3, c(&quot;height&quot;, &quot;weight&quot;), as.numeric) If we are only interested in the final tidy data frame, there is a simpler and cleaner way: the %&gt;% (forward-pipe) operator from the magritrrr package (the tidyverse packages automatically load this operator). Allows to process the output of a function as the input of the following function: it makes the code easier to read and understand: It pipes the output of a function as the first argument of the next function (from left to right): mytibble %&gt;% function1 is equivalent to function1(mytibble) mytibble %&gt;% function2(y) is equivalent to function1(mytibble, y) mytibble %&gt;% function1 %&gt;% function2 is equivalent to function2(function1(mytibble)) If we go back to the previous exercise, we can simplify the code the following way: patients2 &lt;- patients %&gt;% separate(col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) %&gt;% unite(col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) %&gt;% mutate_at(c(&quot;height&quot;, &quot;weight&quot;), as.numeric) HANDS-ON Simplify the following piece of code using the %&gt;% operator: table5_1 &lt;- separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) table5_2 &lt;- unite(data=table5_1, col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) Answer table5_1 &lt;- table5 %&gt;% separate(col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) %&gt;% unite(col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) "],["input-output-with-readr.html", "Part 6 Input / output with *readr", " Part 6 Input / output with *readr "]]
