[["index.html", "Intermediate R: introduction to data wrangling with the Tidyverse (2021) Part 1 Welcome", " Intermediate R: introduction to data wrangling with the Tidyverse (2021) Sarah Bonnin 2021-04-14 Part 1 Welcome About the course The so-called tidyverse set of packages is widely used in the R community for powerful and efficient data reading, tidying, manipulation and visualization. It is one of the most popular and up-to-date set of tools for data analysis and data science using the R language. All tidyverse packages share a common vocabulary/grammar that makes code more intuitive and easier to read that the base R. This 8-hour training aims at introducing some of the tidyverse packages for data wrangling and manipulation: dplyr, tidyr, stringr and readr. Dates, time &amp; location Dates (2021): April 19th + 21rst Time: 9:30-13:30 Location: Online (Zoom: find details in the dedicated Moodle page) Instructors Sarah Bonnin Julia Ponomarenko from the CRG Bioinformatics core facility (office , 4th floor hospital side) Learning objectives Prerequisites This is an intermediate course. Familiarity with R scripting is required: syntax, installation of packages, objects manipulation, data import/export. Material All material is available from this page (https://biocorecrg.github.io/CRG_R_tidyverse_2021) and will be regularly updated. If you want to get the latest version locally, you can: download and uncompress the zip archive keep only the “docs” and \" images\" folders. open the “index.html” file in a web browser. Data import &amp; export: read_csv tibbles characteristics tidy data definition tidyr: separate &amp; unite pivot (long and wide formats): pivot_longer, pivot_wider complete (missing values) “forward-pipe”: %&gt;% from the magrittr package stringr: str_remove str_length str_c (paste) str_sub dplyr: mutate, mutate_at, transmute select, select_if filter summarise, group_by arrange “join” functions count "],["introduction.html", "Part 2 Introduction ", " Part 2 Introduction "],["what-is-the-tidyverse.html", "2.1 What is the “tidyverse”", " 2.1 What is the “tidyverse” A set of packages designed for data science: Preparing / cleaning Wrangling Visualizing All packages share good practices in terms of: Philosophy Grammar Data structure "],["good-reasons-to-learn-at-least-a-bit-how-to-use-it.html", "2.2 Good reasons to learn (at least a bit) how to use it", " 2.2 Good reasons to learn (at least a bit) how to use it More intuitive programming: the names of functions speak for themselves. The code is easier to read than with R base: it facilitates code sharing. More efficient: the functions are quite quick and you need to write less lines to get what you want. Very good documentation and tutorials. Here is a piece of R base code: diamonds2 &lt;- diamonds[diamonds$cut == &quot;Ideal&quot;, c(&quot;cut&quot;, &quot;color&quot;, &quot;carat&quot;, &quot;price&quot;)] diamonds2[order(diamonds2$price, decreasing=TRUE),] ## # A tibble: 21,551 x 4 ## cut color carat price ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Ideal G 1.51 18806 ## 2 Ideal G 2.07 18804 ## 3 Ideal G 2.15 18791 ## 4 Ideal G 2.05 18787 ## 5 Ideal F 1.6 18780 ## 6 Ideal I 2.06 18779 ## 7 Ideal G 1.71 18768 ## 8 Ideal H 2.08 18760 ## 9 Ideal G 2.03 18757 ## 10 Ideal I 2.61 18756 ## # … with 21,541 more rows And its equivalent in the tidyverse: diamonds %&gt;% select(cut, color, carat, price) %&gt;% filter(cut==&quot;Ideal&quot;) %&gt;% arrange(desc(price)) ## # A tibble: 21,551 x 4 ## cut color carat price ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Ideal G 1.51 18806 ## 2 Ideal G 2.07 18804 ## 3 Ideal G 2.15 18791 ## 4 Ideal G 2.05 18787 ## 5 Ideal F 1.6 18780 ## 6 Ideal I 2.06 18779 ## 7 Ideal G 1.71 18768 ## 8 Ideal H 2.08 18760 ## 9 Ideal G 2.03 18757 ## 10 Ideal I 2.61 18756 ## # … with 21,541 more rows "],["tidyverse-core-packages.html", "2.3 Tidyverse core packages", " 2.3 Tidyverse core packages The following 8 packages are included in the core tidyverse version 1.3.0.9000 (current version in April 2021): Data Wrangling and Transformation dplyr tidyr stringr forcats Data Import and Management tibble readr Functional Programming purrr Data Visualization and Exploration ggplot2 logo name description dplyr Package for data manipulation and exploratory data analysis. tidyr Package that aims at creating tidy data. Tidy data describe a standard way of storing data. stringr Package that provides a set of functions for user-friendly string manipulation. forcats Package that helps you deal with factors readr Package for fast and efficient import and export of data. tibble Tibbles are improved - easier to manage - data frames. purrr Package that aims at enhancing R’s functional programming toolkit. It provides a set of tools for working with functions and vectors. ggplot2 Package for data vizualization of graphics based on Leland Wilkinson’s’ Grammar of Graphics: graphics are built one layer at a time. "],["install-and-load-all-tidyverse-package.html", "2.4 Install and load all tidyverse package", " 2.4 Install and load all tidyverse package Install (should be done before the class, as it takes a while!): install.packages(&quot;tidyverse&quot;) Load: library(tidyverse) "],["tibbles.html", "Part 3 Tibbles ", " Part 3 Tibbles "],["what-are-tibbles.html", "3.1 What are tibbles?", " 3.1 What are tibbles? Modern re-thinking of data frame. They leave behind some features (sometimes user-unfriendly) of classical data frames: No string to factor conversion (NOTE: since version 4.0 of R, this is no longer the case for classical data frames) No automatic creation of row names. Column names can be non-valid R variable names (for example, they can start with numbers). You can create a simple tibble as you create a data frame, but with the tibble function: mytibble &lt;- tibble( letters = LETTERS, numbers = 1:26 ) mytibble Convert a data frame to a tibble: mydf &lt;- data.frame(letters = LETTERS, numbers = 1:26) as_tibble(mydf) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## # … with 16 more rows Convert a tibble to a data frame (useful to interact with R code that doesn’t support tibbles): as.data.frame(mytibble) ## letters numbers ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## 16 P 16 ## 17 Q 17 ## 18 R 18 ## 19 S 19 ## 20 T 20 ## 21 U 21 ## 22 V 22 ## 23 W 23 ## 24 X 24 ## 25 Y 25 ## 26 Z 26 "],["displaying-tibbles.html", "3.2 Displaying tibbles", " 3.2 Displaying tibbles The way it prints in the console is different that that of data frames: Dimensions are shown. Information about columns data types (no need for mode() or typeof). Only the first 10 rows are displayed. Only the columns that fit the screen are displayed. If you want to see more rows, set the n parameter in print(): Print the first 15 rows: print(mytibble, n=15) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## # … with 11 more rows Print all rows: print(mytibble, n=Inf) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## 16 P 16 ## 17 Q 17 ## 18 R 18 ## 19 S 19 ## 20 T 20 ## 21 U 21 ## 22 V 22 ## 23 W 23 ## 24 X 24 ## 25 Y 25 ## 26 Z 26 "],["data-types-in-tibbles.html", "3.3 Data types in tibbles", " 3.3 Data types in tibbles When you display a tibble, mote that there is a 3 or 4-letter abbreviation under each column nam: these describe the type of each variable: Abbreviation Description int integers dbl doubles (or real numbers) chr character vectors (or strings) lgl logicals (TRUE or FALSE) fctr factors (categorical variables) date dates dttm date-time (a date + a time) "],["subsetting-manipulating-tibbles.html", "3.4 Subsetting / manipulating tibbles", " 3.4 Subsetting / manipulating tibbles Extract column by name: # with the $ mytibble$letters ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; ## [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # or the [[]] mytibble[[&quot;letters&quot;]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; ## [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # Note: with using simple square brackets, you extract a sub-tibble (2 dimensions) mytibble[&quot;letters&quot;] ## # A tibble: 26 x 1 ## letters ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## 7 G ## 8 H ## 9 I ## 10 J ## # … with 16 more rows Extract column by position/index: # sub-tibble with one column mytibble[, 1] ## # A tibble: 26 x 1 ## letters ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## 7 G ## 8 H ## 9 I ## 10 J ## # … with 16 more rows # corresponding vector mytibble[, 1][[1]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; ## [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; HANDS-ON We will work with the built-in dataset iris: Is iris a tibble? How can you tell? Try to run is_tibble. Convert iris to a tibble. Save in a new object tbl_iris. Show all rows from tbl_iris. Show the first 3 rows from tbl_iris. Extract column Species. Answer # Is iris a tibble? is_tibble(iris) # Convert iris to a tibble. Save in a new object tbl_iris. tbl_iris &lt;- tibble(iris) # Show all rows from tbl_iris. print(tbl_iris, n=Inf) # Show the first 3 rows from tbl_iris. print(tbl_iris, n=3) # Extract column Species. # create a tibble with only one column: tbl_iris[&quot;Species&quot;] # create a vector: tbl_iris[[&quot;Species&quot;]] # same as tbl_iris$Species "],["tidy-data-with-tidyr.html", "Part 4 Tidy data with tidyr ", " Part 4 Tidy data with tidyr "],["what-is-tidy-data.html", "4.1 What is “tidy” data?", " 4.1 What is “tidy” data? Tidy data is where: Each column describes a variable. Each row describes an observation. Each value is a cell. Figure 4.1: Tidy data Example of a tidy data: day month year weight height 12 4 2020 3.5 48 23 8 2019 2.9 50 9 11 2020 3.8 50 Example of untidy data: day month,year weight height 12 4,2020 3.5kg 48 23 8,2019 2.9kg 50 9 11,2020 3.8kg 50 Here we introduce some useful functions from the tidyr package to clean up and organize data so as to obtain tidy data that can then be processed more easily. "],["separate-unite.html", "4.2 Separate &amp; Unite", " 4.2 Separate &amp; Unite Let’s work on the untidy tibble table5 that is a built-in data set from the tidyr package (table5 displays the number of tuberculosis cases documented by the WHO in selected countries): Table 4.1: table5 country century year rate Afghanistan 19 99 745/19987071 Afghanistan 20 00 2666/20595360 Brazil 19 99 37737/172006362 Brazil 20 00 80488/174504898 China 19 99 212258/1272915272 China 20 00 213766/1280428583 4.2.1 Separate Function separate separates (indeed!) a column into 2 or more columns: separate(data, col, into, sep) # separate column &quot;rate&quot; into 2 columns that we name cases and population, based on the &quot;/&quot; separator. table5_1 &lt;- separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot; ) table5_1 ## # A tibble: 6 x 5 ## country century year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745 19987071 ## 2 Afghanistan 20 00 2666 20595360 ## 3 Brazil 19 99 37737 172006362 ## 4 Brazil 20 00 80488 174504898 ## 5 China 19 99 212258 1272915272 ## 6 China 20 00 213766 1280428583 4.2.2 Unite Function unite does just the opposite: it will unite/stick together 2 or (more) columns: unite(data, col, *column names*, sep). # unite columns &quot;century&quot; and &quot;year&quot; table5a_2 &lt;- unite(data=table5_1, col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) table5a_2 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 HANDS-ON Fix the following untidy tibble: patients &lt;- tibble( ID1=c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), ID2=c(12, 13, 14, 15), age=c( 21, 32, 25, 43), c(&quot;188_93&quot;, &quot;167_55&quot;, &quot;155_51&quot;, &quot;175_72&quot;) ) Separate the two variables that are found in the last column into columns height and weight. Unite columns ID1 and ID2 so as to create a unique ID per patient. Answer # Separate the two variables that are found in the last column. patients2 &lt;- separate(data=patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) # Unite columns ID1 and ID2 so as to create a unique ID per patient. patients3 &lt;- unite(data=patients2, col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) Is there a problem with patients3? Display the tibble in the R console… Columns height and weight are treated as characters (because they contained *underscores \"_\"*). We can convert them into numbers with the mutate_at function from the dplyr package: try it! Answer # first argument: the tibble # second argument: a vector of column names to mutate # third argument: how to mutate those columns patients4 &lt;- mutate_at(patients3, c(&quot;height&quot;, &quot;weight&quot;), as.numeric) "],["the-forward-pipe-operator.html", "Part 5 The %&gt;% forward-pipe operator", " Part 5 The %&gt;% forward-pipe operator Let’s review the steps from the previous hands-on: patients2 &lt;- separate(data=patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) patients3 &lt;- unite(data=patients2, col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) patients4 &lt;- mutate_at(patients3, c(&quot;height&quot;, &quot;weight&quot;), as.numeric) If we are only interested in the final tidy data frame (and not in the intermediate objects patients2 and patients3), there is a simpler and cleaner way: The %&gt;% (forward-pipe) operator from the magritrrr package (the tidyverse packages automatically load this operator). The pipe allows to process the output of a function as the input of the following function: it makes the code easier to read and understand: It pipes the output of a function as the first argument of the next function (from left to right): mytibble %&gt;% function1 is equivalent to function1(mytibble) mytibble %&gt;% function2(y) is equivalent to function1(mytibble, y) mytibble %&gt;% function1 %&gt;% function2 is equivalent to function2(function1(mytibble)) If we go back to the previous exercise, we can simplify the code the following way: patients2 &lt;- separate(patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) %&gt;% unite(col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) %&gt;% mutate_at(c(&quot;height&quot;, &quot;weight&quot;), as.numeric) # This is equivalent to: patients2 &lt;- patients %&gt;% separate(col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) %&gt;% unite(col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) %&gt;% mutate_at(c(&quot;height&quot;, &quot;weight&quot;), as.numeric) HANDS-ON Simplify the following piece of code using the %&gt;% operator: table5_1 &lt;- separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) table5_2 &lt;- unite(data=table5_1, col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) Answer table5_1 &lt;- table5 %&gt;% separate(col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) %&gt;% unite(col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) "],["input-output-with-readr.html", "Part 6 Input / output with readr", " Part 6 Input / output with readr readr provides functions for reading in and writing out files. Those functions are up to 10 times faster that the base R equivalent. "],["read.html", "6.1 Read", " 6.1 Read read_delim, read_csv, read_tsv: Read a delimited file into a tibble: Table 6.1: read_delim and derived functions name delim read_delim needs to be set read_csv ,: comma-separated read_tsv : tab-separated Read in a file provided as an example with the readr package: f1 &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;)) ## ## ── Column specification ──────────────────────────────────────────────────────────────────── ## cols( ## mpg = col_double(), ## cyl = col_double(), ## disp = col_double(), ## hp = col_double(), ## drat = col_double(), ## wt = col_double(), ## qsec = col_double(), ## vs = col_double(), ## am = col_double(), ## gear = col_double(), ## carb = col_double() ## ) As you can see, readr prints out the column specifications, so you can make sure the data is read the way it is meant to be. Useful arguments to consider, as you read in the file: n_max : read in a subset. col_names: col_names=FALSE : your data doesn’t contain headers/column names. col_names=c(“A,” “B,” “C”) : you are providing a vector containing column names / header. skip : skip rows. f2 &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;), n_max=5, skip=1, col_names=LETTERS[1:11]) ## ## ── Column specification ──────────────────────────────────────────────────────────────────── ## cols( ## A = col_double(), ## B = col_double(), ## C = col_double(), ## D = col_double(), ## E = col_double(), ## F = col_double(), ## G = col_double(), ## H = col_double(), ## I = col_double(), ## J = col_double(), ## K = col_double() ## ) f2 ## # A tibble: 5 x 11 ## A B C D E F G H I J K ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 "],["write.html", "6.2 Write", " 6.2 Write format_csv format_tsv write_delim write_csv write_tsv HANDS-ON "],["data-manipulation.html", "Part 7 Data manipulation", " Part 7 Data manipulation Package dplyr introduces a grammar of data manipulation. Cheat sheet We will first introduce the 5 intuitively-named key functions from {dplyr}: mutate() adds new variables (columns) that are functions of existing variables select() picks variables (columns) based on their names. filter() picks observations (rows) based on their values. summarise() collapses multiple values down to a single summary. arrange() changes the ordering of the rows. All 5 functions work in a similar and consistent way: The first argument is a data frame or a tibble. The result is a new data frame. Note that {dplyr} never modifies the input: you need to redirect the output and save in a new - or the same - object. We will use the presidential data set. It contains data of the terms of presidents of the USA, from Eisenhower to Obama: Name Term starting date Term ending date of mandate Political party Table 7.1: presidential data set name start end party duration_days Eisenhower 1953-01-20 1961-01-20 Republican 2922 days Kennedy 1961-01-20 1963-11-22 Democratic 1036 days Johnson 1963-11-22 1969-01-20 Democratic 1886 days Nixon 1969-01-20 1974-08-09 Republican 2027 days Ford 1974-08-09 1977-01-20 Republican 895 days Carter 1977-01-20 1981-01-20 Democratic 1461 days Reagan 1981-01-20 1989-01-20 Republican 2922 days Bush 1989-01-20 1993-01-20 Republican 1461 days Clinton 1993-01-20 2001-01-20 Democratic 2922 days Bush 2001-01-20 2009-01-20 Republican 2922 days Obama 2009-01-20 2017-01-20 Democratic 2922 days "],["mutate-transmute.html", "7.1 mutate &amp; transmute", " 7.1 mutate &amp; transmute mutate allows to create new columns that are functions of the existing ones. Create a new column with the duration of each term: # Subtracting column start to colum end mutate(presidential, duration_days=end - start) Notes: Use unquoted column names. Columns are added at the end of the data frame. mutate keeps all columns. If you want to keep only the newly created column(s) (drop the remaining ones): use transmute() instead of mutate(): transmute(presidential, duration_days=end - start) Re-assign to a new - or the same - data frame/tibble using the R assignment operator: &lt;- presidential &lt;- mutate(presidential, duration_days=end - start) If you want to change the name of a column, you can use the function rename: # by the name rename(presidential, President=name) ## # A tibble: 11 x 5 ## President start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 4 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 5 Ford 1974-08-09 1977-01-20 Republican 895 days ## 6 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 7 Reagan 1981-01-20 1989-01-20 Republican 2922 days ## 8 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 9 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 10 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 11 Obama 2009-01-20 2017-01-20 Democratic 2922 days # or the index rename(presidential, President=1) ## # A tibble: 11 x 5 ## President start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 4 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 5 Ford 1974-08-09 1977-01-20 Republican 895 days ## 6 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 7 Reagan 1981-01-20 1989-01-20 Republican 2922 days ## 8 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 9 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 10 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 11 Obama 2009-01-20 2017-01-20 Democratic 2922 days # you can rename several columns rename(presidential, President=name, Political_party=party) ## # A tibble: 11 x 5 ## President start end Political_party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 4 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 5 Ford 1974-08-09 1977-01-20 Republican 895 days ## 6 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 7 Reagan 1981-01-20 1989-01-20 Republican 2922 days ## 8 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 9 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 10 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 11 Obama 2009-01-20 2017-01-20 Democratic 2922 days "],["select.html", "7.2 select", " 7.2 select select will select (and optionally rename) columns/variables in a data frame / tibble. Select column name only from the presidential data set: name start end party duration_days Eisenhower 1953-01-20 1961-01-20 Republican 2922 days Kennedy 1961-01-20 1963-11-22 Democratic 1036 days Johnson 1963-11-22 1969-01-20 Democratic 1886 days Nixon 1969-01-20 1974-08-09 Republican 2027 days Ford 1974-08-09 1977-01-20 Republican 895 days Carter 1977-01-20 1981-01-20 Democratic 1461 days Reagan 1981-01-20 1989-01-20 Republican 2922 days Bush 1989-01-20 1993-01-20 Republican 1461 days Clinton 1993-01-20 2001-01-20 Democratic 2922 days Bush 2001-01-20 2009-01-20 Republican 2922 days Obama 2009-01-20 2017-01-20 Democratic 2922 days select(presidential, name) ## # A tibble: 11 x 1 ## name ## &lt;chr&gt; ## 1 Eisenhower ## 2 Kennedy ## 3 Johnson ## 4 Nixon ## 5 Ford ## 6 Carter ## 7 Reagan ## 8 Bush ## 9 Clinton ## 10 Bush ## 11 Obama Select 2 columns: party and name (in that order): select(presidential, party, name) Rename a column as you select it: select(presidential, party, President=name) ## # A tibble: 11 x 2 ## party President ## &lt;chr&gt; &lt;chr&gt; ## 1 Republican Eisenhower ## 2 Democratic Kennedy ## 3 Democratic Johnson ## 4 Republican Nixon ## 5 Republican Ford ## 6 Democratic Carter ## 7 Republican Reagan ## 8 Republican Bush ## 9 Democratic Clinton ## 10 Republican Bush ## 11 Democratic Obama Select all columns except party with the - sign: select(presidential, -party) ## # A tibble: 11 x 4 ## name start end duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;drtn&gt; ## 1 Eisenhower 1953-01-20 1961-01-20 2922 days ## 2 Kennedy 1961-01-20 1963-11-22 1036 days ## 3 Johnson 1963-11-22 1969-01-20 1886 days ## 4 Nixon 1969-01-20 1974-08-09 2027 days ## 5 Ford 1974-08-09 1977-01-20 895 days ## 6 Carter 1977-01-20 1981-01-20 1461 days ## 7 Reagan 1981-01-20 1989-01-20 2922 days ## 8 Bush 1989-01-20 1993-01-20 1461 days ## 9 Clinton 1993-01-20 2001-01-20 2922 days ## 10 Bush 2001-01-20 2009-01-20 2922 days ## 11 Obama 2009-01-20 2017-01-20 2922 days Select all columns between start and party (with both included) select(presidential, start:party) ## # A tibble: 11 x 3 ## start end party ## &lt;date&gt; &lt;date&gt; &lt;chr&gt; ## 1 1953-01-20 1961-01-20 Republican ## 2 1961-01-20 1963-11-22 Democratic ## 3 1963-11-22 1969-01-20 Democratic ## 4 1969-01-20 1974-08-09 Republican ## 5 1974-08-09 1977-01-20 Republican ## 6 1977-01-20 1981-01-20 Democratic ## 7 1981-01-20 1989-01-20 Republican ## 8 1989-01-20 1993-01-20 Republican ## 9 1993-01-20 2001-01-20 Democratic ## 10 2001-01-20 2009-01-20 Republican ## 11 2009-01-20 2017-01-20 Democratic 7.2.1 select_if Select only columns containing characters with select_if(): select_if(presidential, is.character) ## # A tibble: 11 x 2 ## name party ## &lt;chr&gt; &lt;chr&gt; ## 1 Eisenhower Republican ## 2 Kennedy Democratic ## 3 Johnson Democratic ## 4 Nixon Republican ## 5 Ford Republican ## 6 Carter Democratic ## 7 Reagan Republican ## 8 Bush Republican ## 9 Clinton Democratic ## 10 Bush Republican ## 11 Obama Democratic Select only columns containing a date: HANDS-ON For the next hands-on, we will use th starwars dataset: it contains information about the Star Wars movie characters. Create a new column BMI that contains the BMI of each character (Body Mass Index, calculated as weight in kg / height in m: we will assume that the height column is expressed as cm and the mass column is expressed as kg) Rename column name to character_name. Remove column vehicles and starships. Save the changes to a new tibble starwarsBMI. Answer # Create a new column BMI that contains the BMI of each character mutate(starwars, BMI=mass/(height*0.01)^2) # Rename column name to character_name. rename(starwars, character_name=name) # Remove column `vehicles` and `starships`. select(starwars, -c(vehicles, starships)) # Save all the changes to a new tibble starwarsBMI (use the %&gt;% operator) starwarsBMI &lt;- starwars %&gt;% mutate(BMI=mass/(height*0.01)^2) %&gt;% select(-c(vehicles, starships)) %&gt;% rename(character_name=name) "],["filter.html", "7.3 filter", " 7.3 filter filter() is used to filter rows in a data frame / tibble. Keep rows if party is Democratic: name start end party duration_days Eisenhower 1953-01-20 1961-01-20 Republican 2922 days Kennedy 1961-01-20 1963-11-22 Democratic 1036 days Johnson 1963-11-22 1969-01-20 Democratic 1886 days Nixon 1969-01-20 1974-08-09 Republican 2027 days Ford 1974-08-09 1977-01-20 Republican 895 days Carter 1977-01-20 1981-01-20 Democratic 1461 days Reagan 1981-01-20 1989-01-20 Republican 2922 days Bush 1989-01-20 1993-01-20 Republican 1461 days Clinton 1993-01-20 2001-01-20 Democratic 2922 days Bush 2001-01-20 2009-01-20 Republican 2922 days Obama 2009-01-20 2017-01-20 Democratic 2922 days filter(presidential, party==&quot;Democratic&quot;) ## # A tibble: 5 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 2 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 3 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 4 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 5 Obama 2009-01-20 2017-01-20 Democratic 2922 days You can filter using several variables/columns: filter(presidential, party==&quot;Republican&quot;, name==&quot;Bush&quot;) # This implicity uses the &quot;&amp;&quot;, i.e. the fact that both conditions have to be TRUE filter(presidential, party==&quot;Republican&quot; &amp; name==&quot;Bush&quot;) # Any logical operators can be used filter(presidential, name %in% c(&quot;Bush&quot;, &quot;Kennedy&quot;)) HANDS-ON "],["summarise-group-by.html", "7.4 summarise &amp; group_by", " 7.4 summarise &amp; group_by summarise collapses a data frame to a single row (base R: aggregate()) Get average length of terms: summarise(presidential, mean(duration_days)) ## # A tibble: 1 x 1 ## `mean(duration_days)` ## &lt;drtn&gt; ## 1 2125.091 days Get average length of terms + count of the total of entries: summarise(presidential, mean(duration_days), n()) ## # A tibble: 1 x 2 ## `mean(duration_days)` `n()` ## &lt;drtn&gt; &lt;int&gt; ## 1 2125.091 days 11 You can also give a name to each of the calculations you produce with summarise (and add more calculations!): summarise(presidential, mean_term=mean(duration_days), min_term=min(duration_days), max_term=max(duration_days), count_presidents=n()) ## # A tibble: 1 x 4 ## mean_term min_term max_term count_presidents ## &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;int&gt; ## 1 2125.091 days 895 days 2922 days 11 You can combine summarise with group_by to get, for example, the number of presidents per political party: group_by defines a grouping based on existing variables. summarise then processes the command based on the grouping groups &lt;- group_by(presidential, party) summarise(groups, n()) ## # A tibble: 2 x 2 ## party `n()` ## * &lt;chr&gt; &lt;int&gt; ## 1 Democratic 5 ## 2 Republican 6 # One line, using the %&gt;% operator: group_by(presidential, party) %&gt;% summarise(n()) ## # A tibble: 2 x 2 ## party `n()` ## * &lt;chr&gt; &lt;int&gt; ## 1 Democratic 5 ## 2 Republican 6 Note: the row above is equivalent to using count (a wrapper): count(presidential, party) count(presidential, party) ## # A tibble: 2 x 2 ## party n ## * &lt;chr&gt; &lt;int&gt; ## 1 Democratic 5 ## 2 Republican 6 You can use the same structure to calculate the average length of terms per political party: group_by(presidential, party) %&gt;% summarise(mean(duration_days)) ## # A tibble: 2 x 2 ## party `mean(duration_days)` ## * &lt;chr&gt; &lt;drtn&gt; ## 1 Democratic 2045.4 days ## 2 Republican 2191.5 days HANDS-ON starwars %&gt;% group_by(gender, eye_color) %&gt;% summarise(mycounts=n()) %&gt;% arrange(desc(mycounts)) "],["arrange.html", "7.5 arrange", " 7.5 arrange arrange orders the rows of a data frame by the values of selected columns. Let’s order rows by increasing mandate duration: arrange(presidential, duration_days) ## # A tibble: 11 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Ford 1974-08-09 1977-01-20 Republican 895 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 4 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 5 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 6 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 7 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 8 Reagan 1981-01-20 1989-01-20 Republican 2922 days ## 9 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 10 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 11 Obama 2009-01-20 2017-01-20 Democratic 2922 days # decreasing order: arrange(presidential2, desc(duration_days)) You can use several columns for the sorting arrange(presidential, duration_days, name) ## # A tibble: 11 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Ford 1974-08-09 1977-01-20 Republican 895 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 4 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 5 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 6 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 7 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 8 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 9 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 10 Obama 2009-01-20 2017-01-20 Democratic 2922 days ## 11 Reagan 1981-01-20 1989-01-20 Republican 2922 days If a grouping was done before, you can arrange first by grouping and then by selected variable(s) setting the .by_group=TRUE parameter: mutate(presidential, duration_days=end-start) %&gt;% group_by(party) %&gt;% arrange(duration_days, .by_group=TRUE) HANDS-ON "],["more-useful-functions-from-dplyr.html", "7.6 More useful functions from dplyr", " 7.6 More useful functions from dplyr nth(): extract the nth value of a vector presidential %&gt;% nth(name, 4) extract a single column: presidential %&gt;% pull(name) presidential %&gt;% pull(duration_days, name=name) subset rows using their positions: presidential %&gt;% slice(4) join (left, right etc.) functions count(presidential, party) "],["exercise.html", "7.7 Exercise", " 7.7 Exercise We will work with the storms data set: positions and attributes of 198 tropical storms, measured every 6 hours. Remove columns month, day, hour, lat, long, ts_diameter and hu_diameter. Calculate the median pressure for each storm status. Calculate the minimum wind speed for each storm (name). What storm has the minimum wind speed? Calculate how many storms happened each year. TIP: find what distinct() from the dplyr package can do… What are the years with the maximum number of storms? Answer # 1. Remove columns month, day, hour, lat, long, ts_diameter and hu_diameter. # remove columns select(storms, -lat, -long, -ts_diameter, -hu_diameter) # same as: select(storms, -c(lat, long, ts_diameter, hu_diameter)) # 2. Calculate the median pressure for each storm status. # group by status and calculate median pressure per storm status select(storms, -lat, -long, -ts_diameter, -hu_diameter) %&gt;% group_by(status) %&gt;% summarise(median(pressure)) ## # A tibble: 3 x 2 ## status `median(pressure)` ## * &lt;chr&gt; &lt;dbl&gt; ## 1 hurricane 973 ## 2 tropical depression 1008 ## 3 tropical storm 1000 # 3. Calculate the minimum wind speed for each storm (name). # group storms by name and calculate minimum wind speed storms %&gt;% group_by(name) %&gt;% summarise(min_wind = min(wind)) # what storm(s) has/have the smallest minimum wind speed? storms %&gt;% group_by(name) %&gt;% summarise(min_wind = min(wind)) %&gt;% slice_min(min_wind) # 4. Calculate how many storms happened each year. # get unique rows when considering both name and year columns distinct(storms, name, year) # group by year and count the number of storms distinct(storms, name, year) %&gt;% group_by(year) %&gt;% summarise(storms_per_year=n()) # What are the years with the **maximum** number of storms? distinct(storms, name, year) %&gt;% group_by(year) %&gt;% summarise(storms_per_year=n()) %&gt;% arrange(desc(storms_per_year)) %&gt;% head() "],["handling-missing-values.html", "Part 8 Handling missing values", " Part 8 Handling missing values tidyr::drop_na: drop rows containing missing values. Create a tibble that contains missing (NA) values: dfwithNA &lt;- tibble(x = c(1, 2, NA, 5), y = c(&quot;a&quot;, NA, &quot;b&quot;, &quot;c&quot;)) dfwithNA ## # A tibble: 4 x 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 &lt;NA&gt; ## 3 NA b ## 4 5 c Remove rows that contain NA values with drop_na: drop_na(dfwithNA) ## # A tibble: 2 x 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 5 c tidyr::replace_na: change NA values to a selected value (one per column): # replace NAs by 0s in column &quot;x&quot;, and by &quot;k&quot; in column &quot;y&quot; replace_na(dfwithNA, list(x=0, y=&quot;k&quot;)) ## # A tibble: 4 x 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 k ## 3 0 b ## 4 5 c tidyr::complete: turns implicit missing values into explicit missing values: df &lt;- tibble( patient = c(&quot;Patient1&quot;, &quot;Patient1&quot;, &quot;Patient2&quot;, &quot;Patient3&quot;, &quot;Patient3&quot;), treatment = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;), value1 = 1:5, value2 = 4:8 ) # Missing a row for Patient2 / Treatment B: add it and fill in with NA values: complete(df, patient, treatment) ## # A tibble: 6 x 4 ## patient treatment value1 value2 ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Patient1 A 1 4 ## 2 Patient1 B 2 5 ## 3 Patient2 A 3 6 ## 4 Patient2 B NA NA ## 5 Patient3 A 4 7 ## 6 Patient3 B 5 8 # If you want to fill it missing other values that NA, you can use the fill parameter complete(df, patient, treatment, fill=list(value1=0, value2=NA)) ## # A tibble: 6 x 4 ## patient treatment value1 value2 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Patient1 A 1 4 ## 2 Patient1 B 2 5 ## 3 Patient2 A 3 6 ## 4 Patient2 B 0 NA ## 5 Patient3 A 4 7 ## 6 Patient3 B 5 8 In practice: what if you have NA values, along with empty cells and “customized” missing values? dfwithNA2 &lt;- tibble(x = c(1, 2, NA, 5, &quot;&quot;, 4), y = c(&quot;a&quot;, NA, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;missing&quot;)) Replace empty cells and “customized” missing values with NA with na_if: dfwithNA2 %&gt;% na_if(&quot;missing&quot;) %&gt;% na_if(&quot;&quot;) ## # A tibble: 6 x 2 ## x y ## &lt;chr&gt; &lt;chr&gt; ## 1 1 a ## 2 2 &lt;NA&gt; ## 3 &lt;NA&gt; b ## 4 5 c ## 5 &lt;NA&gt; d ## 6 4 &lt;NA&gt; More complex solution: with mutate and across: across: apply the same transformation to multiple columns. It takes the following parameters: .fns: function to apply to each of the selected columns. .cols: columns to transform: by default, all columns will be transformed. # across: dfwithNA2 %&gt;% mutate(across(.fns = ~replace(., . == &quot;&quot; | . == &quot;missing&quot;, NA))) ## # A tibble: 6 x 2 ## x y ## &lt;chr&gt; &lt;chr&gt; ## 1 1 a ## 2 2 &lt;NA&gt; ## 3 &lt;NA&gt; b ## 4 5 c ## 5 &lt;NA&gt; d ## 6 4 &lt;NA&gt; HANDS-ON "]]
