[["index.html", "Intermediate R: introduction to data wrangling with the Tidyverse (2021) Part 1 Welcome", " Intermediate R: introduction to data wrangling with the Tidyverse (2021) Sarah Bonnin 2021-04-21 Part 1 Welcome About the course The so-called tidyverse set of packages is widely used in the R community for powerful and efficient data reading, tidying, manipulation and visualization. It is one of the most popular and up-to-date set of tools for data analysis and data science using the R language. All tidyverse packages share a common vocabulary/grammar that makes code more intuitive and easier to read than the base R. This 8-hour training aims at introducing some of the tidyverse packages and functions for data wrangling and manipulation: dplyr, tidyr, stringr and readr. Dates, time &amp; location Dates (2021): April 19th + 21rst Time: 9:30-13:30 Location: Online (Zoom: find details in the dedicated Moodle page) Instructors Sarah Bonnin Julia Ponomarenko from the CRG Bioinformatics core facility (office , 4th floor hospital side) Prerequisites This is an intermediate course. Familiarity with R scripting is required: syntax, installation of packages, objects manipulation, data import/export. Material All material is available from this page (https://biocorecrg.github.io/CRG_R_tidyverse_2021) and will be regularly updated. If you want to get the latest version locally, you can: download and uncompress the zip archive keep only the “docs” and \" images\" folders. open the “index.html” file in a web browser. Program Data import &amp; export with {readr} tibbles characteristics and manipulation tidy data definition tidying data with {tidyr}: separate &amp; unite pivot (long and wide formats): pivot_longer, pivot_wider complete (missing values) “forward-pipe”: %&gt;% from the {magrittr} package Data manipulation with {dplyr}: mutate, mutate_at, transmute select, select_if filter summarise, group_by arrange “join” functions count Handling missing data string manipulation with {stringr}: str_remove str_length str_c (paste) str_sub "],["introduction.html", "Part 2 Introduction ", " Part 2 Introduction "],["what-is-the-tidyverse.html", "2.1 What is the “tidyverse”", " 2.1 What is the “tidyverse” A set of packages designed for data science: Importing data into R Preparing / Cleaning data Data wrangling (tidying and transforming data) Visualizing data All packages share good practices in terms of: Philosophy Grammar Data structure "],["good-reasons-to-learn-at-least-a-bit-how-to-use-it.html", "2.2 Good reasons to learn (at least a bit) how to use it", " 2.2 Good reasons to learn (at least a bit) how to use it More intuitive programming: the names of functions speak for themselves. The code is easier to read than with R base: it facilitates code sharing. More efficient: the functions are quite quick (coded more efficiently). Very good documentation and tutorials. Here is a piece of R base code: diamonds2 &lt;- diamonds[diamonds$cut == &quot;Ideal&quot;, c(&quot;cut&quot;, &quot;color&quot;, &quot;carat&quot;, &quot;price&quot;)] diamonds2[order(diamonds2$price, decreasing=TRUE),] And its equivalent in the tidyverse: diamonds %&gt;% select(cut, color, carat, price) %&gt;% filter(cut==&quot;Ideal&quot;) %&gt;% arrange(desc(price)) "],["tidyverse-core-packages.html", "2.3 Tidyverse core packages", " 2.3 Tidyverse core packages The following 8 packages are included in the core tidyverse version 1.3.0.9000 (current version in April 2021): Data Import and Management tibble readr Data Wrangling (Tyding and Transformation) dplyr tidyr stringr forcats Data Visualization and Exploration ggplot2 Functional Programming purrr logo name description dplyr Package for data manipulation and exploratory data analysis. tidyr Package that aims at creating tidy data. Tidy data describe a standard way of storing data. stringr Package that provides a set of functions for user-friendly string manipulation. forcats Package that helps you deal with factors readr Package for fast and efficient import and export of data. tibble Tibbles are improved - easier to manage - data frames. purrr Package that aims at enhancing R’s functional programming toolkit. It provides a set of tools for working with functions and vectors. ggplot2 Package for data vizualization of graphics based on Leland Wilkinson’s’ Grammar of Graphics: graphics are built one layer at a time. "],["install-and-load-all-tidyverse-package.html", "2.4 Install and load all tidyverse package", " 2.4 Install and load all tidyverse package Install (should be done before the class, as it takes a while!): install.packages(&quot;tidyverse&quot;) Load: library(tidyverse) "],["tibbles.html", "Part 3 Tibbles ", " Part 3 Tibbles "],["what-are-tibbles.html", "3.1 What are tibbles?", " 3.1 What are tibbles? Modern re-thinking of data frame. They leave behind some (sometimes user-unfriendly) features of classical data frames: No string to factor conversion (NOTE: since version 4.0 of R, this is no longer the case for classical data frames) No automatic creation of row names. Column names can be non-valid R variable names (for example, they can start with numbers). "],["creating-tibbles.html", "3.2 Creating tibbles", " 3.2 Creating tibbles You can create a simple tibble with the tibble function, similarly as when you create a data frame: mytibble &lt;- tibble( letters = LETTERS, numbers = 1:26 ) Convert a data frame to a tibble: mydf &lt;- data.frame(letters = LETTERS, numbers = 1:26) as_tibble(mydf) Convert a tibble to a data frame (useful to interact with R code that doesn’t support tibbles): as.data.frame(mytibble) "],["displaying-tibbles.html", "3.3 Displaying tibbles", " 3.3 Displaying tibbles The way it prints in the console is different than that of data frames: Dimensions are shown. Information about columns data types (no need for mode() or typeof). Only the first 10 rows are displayed. Only the columns that fit the screen are displayed. If you want to see more rows, set the n parameter in print(): Print the first 15 rows: print(mytibble, n=15) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## # … with 11 more rows Print all rows: print(mytibble, n=Inf) ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## 16 P 16 ## 17 Q 17 ## 18 R 18 ## 19 S 19 ## 20 T 20 ## 21 U 21 ## 22 V 22 ## 23 W 23 ## 24 X 24 ## 25 Y 25 ## 26 Z 26 "],["data-types-in-tibbles.html", "3.4 Data types in tibbles", " 3.4 Data types in tibbles When you display a tibble, note that there is a 3 or 4-letter abbreviation under each column name that describes the type of each variable: Abbreviation Description int integers dbl doubles (or real numbers) chr character vectors (or strings) lgl logicals (TRUE or FALSE) fctr factors (categorical variables) date dates dttm date-time (a date + a time) "],["subsetting-manipulating-tibbles.html", "3.5 Subsetting / manipulating tibbles", " 3.5 Subsetting / manipulating tibbles Extract column by name: # with the $ mytibble$letters ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; ## [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # or the [[]] mytibble[[&quot;letters&quot;]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; ## [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # Note: with simple square brackets, you extract a sub-tibble (it remains a 2 dimensional object) mytibble[&quot;letters&quot;] ## # A tibble: 26 x 1 ## letters ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## 7 G ## 8 H ## 9 I ## 10 J ## # … with 16 more rows Extract column by position/index: # sub-tibble with one column mytibble[, 1] ## # A tibble: 26 x 1 ## letters ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## 7 G ## 8 H ## 9 I ## 10 J ## # … with 16 more rows # corresponding vector mytibble[[1]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; ## [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; HANDS-ON We will work with the built-in dataset iris: Is iris a tibble? How can you tell? Try to run is_tibble. Convert iris to a tibble. Save in a new object tbl_iris. Run is_tibble on tbl_iris. Show all rows of tbl_iris. Show the first 3 rows of tbl_iris. Extract column Species. Answer # Is iris a tibble? is_tibble(iris) # Convert iris to a tibble. Save in a new object tbl_iris. tbl_iris &lt;- tibble(iris) # Show all rows from tbl_iris. print(tbl_iris, n=Inf) # Show the first 3 rows from tbl_iris. print(tbl_iris, n=3) # Extract column Species. # create a tibble with only one column: tbl_iris[&quot;Species&quot;] # create a vector: tbl_iris[[&quot;Species&quot;]] # same as tbl_iris$Species "],["input-output-with-readr.html", "Part 4 Input / output with readr", " Part 4 Input / output with readr readr provides functions for reading in and writing out files. Those functions : are up to 10 times faster that the base R equivalent. automatically uncompress files with .gz, .bz2, .xz or .zip extensions. automatically download files starting with http://, https://, ftp://, or ftps://. "],["read.html", "4.1 Read", " 4.1 Read read_delim, read_csv, read_tsv: read a delimited file into a tibble: Table 4.1: read_delim and derived functions name delim read_delim needs to be set read_csv ,: comma-separated read_tsv : tab-separated Read in a file provided as an example with the readr package: f1 &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;)) ## ## ── Column specification ─────────────────────────────────────────────────────────────────────── ## cols( ## mpg = col_double(), ## cyl = col_double(), ## disp = col_double(), ## hp = col_double(), ## drat = col_double(), ## wt = col_double(), ## qsec = col_double(), ## vs = col_double(), ## am = col_double(), ## gear = col_double(), ## carb = col_double() ## ) Read in a file available online (https protocol): f2 &lt;- read_tsv(&quot;https://public-docs.crg.es/biocore/projects/training/R_tidyverse_2021/inputB.txt&quot;) ## ## ── Column specification ─────────────────────────────────────────────────────────────────────── ## cols( ## State = col_character(), ## Population = col_double(), ## Capital = col_character(), ## Eurozone = col_logical() ## ) As you can see, readr prints out the column specifications, so you can make sure the data is read the way it is meant to be. Useful arguments to consider, as you read in the file: n_max=k : read in a subset (first k rows). col_names: col_names=FALSE : your data doesn’t contain headers/column names. col_names=c(“A,” “B,” “C”) : you are providing a vector containing column names / header. skip=j : skip the first j rows. f1 &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;), n_max=5, skip=1, col_names=LETTERS[1:11]) ## ## ── Column specification ─────────────────────────────────────────────────────────────────────── ## cols( ## A = col_double(), ## B = col_double(), ## C = col_double(), ## D = col_double(), ## E = col_double(), ## F = col_double(), ## G = col_double(), ## H = col_double(), ## I = col_double(), ## J = col_double(), ## K = col_double() ## ) f1 ## # A tibble: 5 x 11 ## A B C D E F G H I J K ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 "],["write.html", "4.2 Write", " 4.2 Write write_delim, write_csv, write_tsv: write a tibble into a delimited file: Table 4.2: write_delim and derived functions name delim write_delim needs to be set write_csv ,: comma-separated write_tsv : tab-separated write_csv(x=f2, file=&quot;test_write_csv.csv&quot;) # to get the exact same in base R, you would need to set a few additional parameters: write.csv(x=f2, file=&quot;test_base_write_csv.csv&quot;, quote=F, row.names = F) HANDS-ON Read in file readr_example(\"mtcars.csv.zip\") (also provided with the readr package) With base R coding, remove rows where mpg &gt; 20 Write this new tibble to a tab-separated file. Answer # Read in file readr_example(&quot;mtcars.csv.zip&quot;) Cars &lt;- read_csv(readr_example(&quot;mtcars.csv.zip&quot;)) # With base R coding, remove rows where mpg &gt; 20 mpg20 &lt;- Cars[Cars$mpg &gt; 20, ] # Write this new tibble to a tab-separated file. write_tsv(mpg20, &quot;mtcars_mpg20.txt&quot;) "],["tidy-data-with-tidyr.html", "Part 5 Tidy data with tidyr ", " Part 5 Tidy data with tidyr "],["what-is-tidy-data.html", "5.1 What is “tidy” data?", " 5.1 What is “tidy” data? Tidy data is where: Each column describes a variable. Each row describes an observation. Each value is a cell. Figure 5.1: Tidy data. Source Example of a tidy data: day month year weight height 12 4 2020 3.5 48 23 8 2019 2.9 50 9 11 2020 3.8 50 Example of untidy data: day month,year weight height 12 4,2020 3.5kg 48 23 8,2019 2.9kg 50 9 11,2020 3.8kg 50 Here we introduce some useful functions from the tidyr package to clean up and organize data so as to obtain tidy data that can then be processed more easily. "],["separate-unite.html", "5.2 Separate &amp; Unite", " 5.2 Separate &amp; Unite Let’s work on the untidy tibble table5, a built-in data set from the tidyr package (table5 displays the number of tuberculosis cases documented by the WHO in selected countries): Table 5.1: table5 country century year rate Afghanistan 19 99 745/19987071 Afghanistan 20 00 2666/20595360 Brazil 19 99 37737/172006362 Brazil 20 00 80488/174504898 China 19 99 212258/1272915272 China 20 00 213766/1280428583 5.2.1 Separate Function separate separates (indeed!) a column into 2 or more columns, given a specified field separator: separate(data, col, into, sep) # separate column &quot;rate&quot; into 2 columns that we name cases and population, based on the &quot;/&quot; separator. table5_1 &lt;- separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot; ) table5_1 ## # A tibble: 6 x 5 ## country century year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745 19987071 ## 2 Afghanistan 20 00 2666 20595360 ## 3 Brazil 19 99 37737 172006362 ## 4 Brazil 20 00 80488 174504898 ## 5 China 19 99 212258 1272915272 ## 6 China 20 00 213766 1280428583 The default field separator is a regular expression that matches any sequence of non-alphanumeric values. So this would work well in our example: separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;) ) ## # A tibble: 6 x 5 ## country century year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745 19987071 ## 2 Afghanistan 20 00 2666 20595360 ## 3 Brazil 19 99 37737 172006362 ## 4 Brazil 20 00 80488 174504898 ## 5 China 19 99 212258 1272915272 ## 6 China 20 00 213766 1280428583 It is good practice to explicitly specify the field separator, so as not to get any bad surprise. 5.2.2 Unite Function unite does just the opposite: it will unite/stick together 2 or (more) columns: unite(data, col, column names, sep). # unite columns &quot;century&quot; and &quot;year&quot; table5a_2 &lt;- unite(data=table5_1, col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) table5a_2 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 HANDS-ON Fix the following untidy tibble: patients &lt;- tibble( ID1=c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), ID2=c(12, 13, 14, 15), age=c( 21, 32, 25, 43), c(&quot;188_93&quot;, &quot;167_55&quot;, &quot;155_51&quot;, &quot;175_72&quot;) ) Separate the two variables that are found in the last column into columns height and weight: save in object patients2. Unite columns ID1 and ID2 so as to create a unique ID per patient: save in patients3. Answer # Separate the two variables that are found in the last column. patients2 &lt;- separate(data=patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;) # Unite columns ID1 and ID2 so as to create a unique ID per patient. patients3 &lt;- unite(data=patients2, col=&quot;ID&quot;, c(&quot;ID1&quot;, &quot;ID2&quot;), sep=&quot;&quot;) Is there a problem with patients3? Display the tibble in the R console… Columns height and weight are treated as characters (because they originally contained underscores \"_\" !). We can convert them into numbers with the convert=TRUE parameter in separate: # convert=TRUE: runs `type.convert` fonction (that converts data to appropriate type) patients2 &lt;- separate(data=patients, col=4, into=c(&quot;height&quot;, &quot;weight&quot;), sep=&quot;_&quot;, convert=TRUE) "],["pivoting-data.html", "5.3 Pivoting data", " 5.3 Pivoting data The examples given before were obviously untidy: two values in one cell, date split in two different columns. It will happen that the format of the data you are usually working with is NOT tidy. Example: here we create a tibble that contains the expression of 4 genes in 4 samples: the gene expression is measured at two time points and for two experimental conditions: df_expr &lt;- tibble(gene=c(&quot;Fgfrl1&quot;, &quot;Usp34&quot;, &quot;Mlf2&quot;, &quot;Gga1&quot;), KO_t0=1:4, KO_t10=5:2, WT_t0=6:3, WT_t10=0:3 ) Why this tibble can’t be considered tidy? * One variable (expression) is spread across 4 columns. In order to fix this, we can use the pivot_longer function: we will increase the number of rows and decrease the number of columns: pivot_longer(df_expr, cols=c(&quot;KO_t0&quot;, &quot;KO_t10&quot;, &quot;WT_t0&quot;, &quot;WT_t10&quot;) ) ## # A tibble: 16 x 3 ## gene name value ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Fgfrl1 KO_t0 1 ## 2 Fgfrl1 KO_t10 5 ## 3 Fgfrl1 WT_t0 6 ## 4 Fgfrl1 WT_t10 0 ## 5 Usp34 KO_t0 2 ## 6 Usp34 KO_t10 4 ## 7 Usp34 WT_t0 5 ## 8 Usp34 WT_t10 1 ## 9 Mlf2 KO_t0 3 ## 10 Mlf2 KO_t10 3 ## 11 Mlf2 WT_t0 4 ## 12 Mlf2 WT_t10 2 ## 13 Gga1 KO_t0 4 ## 14 Gga1 KO_t10 2 ## 15 Gga1 WT_t0 3 ## 16 Gga1 WT_t10 3 Now only one column - value - contains the expression variable. We can change the name of the newly created columns with parameters values_to (where the values are stored) and names_to (where the former column names are stored): expr_long &lt;- pivot_longer(df_expr, cols=c(&quot;KO_t0&quot;, &quot;KO_t10&quot;, &quot;WT_t0&quot;, &quot;WT_t10&quot;), values_to=&quot;expression&quot;, names_to=&quot;sample&quot; ) Is there anything else that we could do here, to make the data even more tidy? There are 2 variables in column sample: samples experimental group (KO or WT) and time point (t0 and t10): we can separate them. # we can add &quot;remove=FALSE&quot; so as to keep the original column (sample name), that can be useful in this case: expr_tidy &lt;- separate(expr_long, col=sample, into=c(&quot;group&quot;, &quot;time&quot;), sep=&quot;_&quot;, remove=FALSE ) The pivot_wider function does just the opposite: when an observation is scattered across multiple rows, you can move it back to a column. Let’s take the following example, where expression of 2 genes is measured under two conditions (KO and WT) using two techniques (RNA-seq and qPCR): df_expr2 &lt;- tibble(gene=c(rep(&quot;Fgfrl1&quot;, 4), rep(&quot;Mlf2&quot;, 4)), group=rep(rep(c(&quot;KO&quot;, &quot;WT&quot;), each=2), 2), type=rep(c(&quot;counts_rnaseq&quot;, &quot;Ct_qpcr&quot;), 4), value=c(10, 25, 8, 22, 7, 23, 11, 28) ) Here, it would make sense to have a column counts_rnaseq and a column Ct_qpcr, which would contain their corresponding values: df_expr2_wider &lt;- pivot_wider(df_expr2, names_from=type, values_from=value) HANDS-ON Make the following data frame tidy! df_w &lt;- tibble(Name=c(&quot;Anna&quot;, &quot;Jordi&quot;, &quot;Laura&quot;, &quot;Miquel&quot;), Weight_day0=c(67, 72, 62, 85), Weight_day10=c(65, 73, 66, 80), ) Answer # `pivot_longer` on &quot;Weight&quot; columns: df_w2 &lt;- pivot_longer(df_w, cols=c(&quot;Weight_day0&quot;, &quot;Weight_day10&quot;), values_to=&quot;weight&quot;, names_to=&quot;day&quot; ) # `separate` on the &quot;day&quot; column # into=c(NA, &quot;day&quot;): the first output is ignored (in the), the &quot;Weight&quot; strings df_w3 &lt;- separate(df_w2, col = &quot;day&quot;, sep=&quot;_&quot;, into=c(NA, &quot;day&quot;) ) # If you want to keep only &quot;0&quot; and &quot;10&quot;, you can use &quot;day&quot; as a field separator (optionally set convert=TRUE if you want to convert the newly created column to numeric values) df_w4 &lt;- separate(df_w2, col = &quot;day&quot;, sep=&quot;day&quot;, into=c(NA, &quot;day&quot;), convert=TRUE ) # If you want to remove &quot;day&quot; from an existing tibble, you can also use the str_remove function from the stringr package, and optionally add a conversion step: df_w3$day &lt;- as.numeric(str_remove(df_w3$day, &quot;day&quot;)) "],["the-forward-pipe-operator.html", "Part 6 The %&gt;% forward-pipe operator", " Part 6 The %&gt;% forward-pipe operator Let’s review the steps from the previous hands-on: df_w2 &lt;- pivot_longer(df_w, cols=c(&quot;Weight_day0&quot;, &quot;Weight_day10&quot;), values_to=&quot;weight&quot;, names_to=&quot;day&quot; ) df_w3 &lt;- separate(df_w2, col = &quot;day&quot;, sep=&quot;_&quot;, into=c(NA, &quot;day&quot;) ) If we are only interested in the final tidy data frame (and not in the intermediate object df_w2), there is a simple and clean way to combine all steps. The %&gt;% (forward-pipe) operator from the magritrrr package (the tidyverse packages automatically load this operator): The pipe allows to process the output of a function as the input of the following function: it makes the code easier to read and understand: It pipes the output of a function as the first argument of the next function (from left to right): mytibble %&gt;% function1 is equivalent to function1(mytibble) mytibble %&gt;% function2(y) is equivalent to function1(mytibble, y) mytibble %&gt;% function1 %&gt;% function2 is equivalent to function2(function1(mytibble)) If we go back to the previous exercise, we can simplify the code the following way: df_w_clean &lt;- pivot_longer(df_w, cols=c(&quot;Weight_day0&quot;, &quot;Weight_day10&quot;), values_to=&quot;weight&quot;, names_to=&quot;day&quot;) %&gt;% separate(col = &quot;day&quot;, into=c(NA, &quot;day&quot;)) # This is equivalent to: df_w_clean &lt;- df_w %&gt;% pivot_longer(cols=c(&quot;Weight_day0&quot;, &quot;Weight_day10&quot;), values_to=&quot;weight&quot;, names_to=&quot;day&quot;) %&gt;% separate(col = &quot;day&quot;, into=c(NA, &quot;day&quot;)) HANDS-ON Simplify the following piece of code using the %&gt;% operator: table5_1 &lt;- separate(data=table5, col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) table5_2 &lt;- unite(data=table5_1, col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) Answer table5_1 &lt;- table5 %&gt;% separate(col=rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) %&gt;% unite(col=year, c(&quot;century&quot;, &quot;year&quot;), sep=&quot;&quot;) "],["data-manipulation.html", "Part 7 Data manipulation", " Part 7 Data manipulation Package dplyr introduces a grammar of data manipulation. See the nice cheat sheet We will first introduce the 5 intuitively-named key functions from {dplyr}: Table 7.1: the 5 core dplyr functions name what.it.does mutate adds new variables (columns) that are functions of existing variables select picks variables (columns) based on their names. filter picks observations (rows) based on their values. summarise collapses multiple values down to a single summary. arrange changes the ordering of the rows. All 5 functions work in a similar and consistent way: The first argument is the input: a data frame or a tibble. The output is a new tibble. Note that {dplyr} never modifies the input: you need to redirect the output and save in a new - or the same - object. We will use the presidential data set from the ggplot2 package. It contains data of the terms of presidents of the USA, from Eisenhower to Obama: Name Term starting date Term ending date of mandate Political party Table 7.2: presidential data set name start end party Eisenhower 1953-01-20 1961-01-20 Republican Kennedy 1961-01-20 1963-11-22 Democratic Johnson 1963-11-22 1969-01-20 Democratic Nixon 1969-01-20 1974-08-09 Republican Ford 1974-08-09 1977-01-20 Republican Carter 1977-01-20 1981-01-20 Democratic Reagan 1981-01-20 1989-01-20 Republican Bush 1989-01-20 1993-01-20 Republican Clinton 1993-01-20 2001-01-20 Democratic Bush 2001-01-20 2009-01-20 Republican Obama 2009-01-20 2017-01-20 Democratic "],["mutate-transmute.html", "7.1 mutate &amp; transmute", " 7.1 mutate &amp; transmute mutate allows to create new columns that are functions of the existing ones. Create a new column with the duration of each term: # Subtracting column start to column end mutate(presidential, duration_days=end-start) Notes: Use unquoted column names. Columns are added at the end of the data frame. mutate keeps all columns. You can change where the column is added (if you don’t want it to be added at the last position): # add it before column &quot;start&quot; mutate(presidential, duration_days=end-start, .before=start) # add it after column &quot;end&quot; mutate(presidential, duration_days=end-start, .after=end) If you want to keep only the newly created column(s) (drop the remaining ones): use transmute() instead of mutate(): transmute(presidential, duration_days=end - start) Re-assign to a new - or the same - data frame/tibble using the usual R assignment operator: &lt;- presidential2 &lt;- mutate(presidential, duration_days=end - start) If you want to change the name of a column, you can use the function rename: # using the column name: rename(presidential2, President=name) # or the column index: rename(presidential2, President=1) # you can rename several columns using the same command: rename(presidential2, President=name, Political_party=party) "],["select.html", "7.2 select", " 7.2 select select will select (and optionally rename) columns/variables in a data frame / tibble. Select column “name” only from the presidential2 object: name start end party duration_days Eisenhower 1953-01-20 1961-01-20 Republican 2922 days Kennedy 1961-01-20 1963-11-22 Democratic 1036 days Johnson 1963-11-22 1969-01-20 Democratic 1886 days Nixon 1969-01-20 1974-08-09 Republican 2027 days Ford 1974-08-09 1977-01-20 Republican 895 days Carter 1977-01-20 1981-01-20 Democratic 1461 days Reagan 1981-01-20 1989-01-20 Republican 2922 days Bush 1989-01-20 1993-01-20 Republican 1461 days Clinton 1993-01-20 2001-01-20 Democratic 2922 days Bush 2001-01-20 2009-01-20 Republican 2922 days Obama 2009-01-20 2017-01-20 Democratic 2922 days select(presidential2, name) Select 2 columns: party and name (in that order): select(presidential2, party, name) Rename a column as you select it: select(presidential2, party, President=name) Select all columns except party with the - sign: select(presidential2, -party) Select all columns between start and party (with both columns included) select(presidential2, start:party) ## # A tibble: 11 x 3 ## start end party ## &lt;date&gt; &lt;date&gt; &lt;chr&gt; ## 1 1953-01-20 1961-01-20 Republican ## 2 1961-01-20 1963-11-22 Democratic ## 3 1963-11-22 1969-01-20 Democratic ## 4 1969-01-20 1974-08-09 Republican ## 5 1974-08-09 1977-01-20 Republican ## 6 1977-01-20 1981-01-20 Democratic ## 7 1981-01-20 1989-01-20 Republican ## 8 1989-01-20 1993-01-20 Republican ## 9 1993-01-20 2001-01-20 Democratic ## 10 2001-01-20 2009-01-20 Republican ## 11 2009-01-20 2017-01-20 Democratic 7.2.1 select_if Select only columns containing characters with select_if(): # select columns containing characters: select_if(presidential2, is.character) ## # A tibble: 11 x 2 ## name party ## &lt;chr&gt; &lt;chr&gt; ## 1 Eisenhower Republican ## 2 Kennedy Democratic ## 3 Johnson Democratic ## 4 Nixon Republican ## 5 Ford Republican ## 6 Carter Democratic ## 7 Reagan Republican ## 8 Bush Republican ## 9 Clinton Democratic ## 10 Bush Republican ## 11 Obama Democratic Select only columns containing a date with the is.Date function from the lubridate package: select_if(presidential2, lubridate::is.Date) ## # A tibble: 11 x 2 ## start end ## &lt;date&gt; &lt;date&gt; ## 1 1953-01-20 1961-01-20 ## 2 1961-01-20 1963-11-22 ## 3 1963-11-22 1969-01-20 ## 4 1969-01-20 1974-08-09 ## 5 1974-08-09 1977-01-20 ## 6 1977-01-20 1981-01-20 ## 7 1981-01-20 1989-01-20 ## 8 1989-01-20 1993-01-20 ## 9 1993-01-20 2001-01-20 ## 10 2001-01-20 2009-01-20 ## 11 2009-01-20 2017-01-20 HANDS-ON For the next hands-on, we will use th starwars dataset: it contains information about the Star Wars movie characters: name height mass hair_color skin_color eye_color birth_year sex gender Luke Skywalker 172 77 blond fair blue 19.0 male masculine C-3PO 167 75 NA gold yellow 112.0 none masculine R2-D2 96 32 NA white, blue red 33.0 none masculine Darth Vader 202 136 none white yellow 41.9 male masculine Leia Organa 150 49 brown light brown 19.0 female feminine Create a new column BMI that contains the BMI of each character (Body Mass Index, calculated as weight in kg / (height in m)^2: we will assume that the height column is expressed as cm and the mass column is expressed as kg) Rename column name to character_name. Remove columns vehicles and starships. Save all the changes into the new tibble starwarsBMI (use the %&gt;% !). Answer # Create a new column BMI that contains the BMI of each character mutate(starwars, BMI=mass/(height*0.01)^2) # Rename column name to character_name. rename(starwars, character_name=name) # Remove columns `vehicles` and `starships`. select(starwars, -c(vehicles, starships)) # Save all the changes into the new tibble starwarsBMI (use the %&gt;% operator) starwarsBMI &lt;- starwars %&gt;% mutate(BMI=mass/(height*0.01)^2) %&gt;% select(-c(vehicles, starships)) %&gt;% rename(character_name=name) 7.2.2 select using patterns Some select helpers are available, that help you select columns given certain patterns in their names: Table 7.3: select helpers name description starts_with starts with a prefix ends_with ends with a suffix contains contains a literal string matches matches a regular expression num_range matches a numerical range like x01, x02, x03 For example, select only columns from the starwars dataset which name end with “color”: select(starwars, ends_with(&quot;color&quot;)) ## # A tibble: 87 x 3 ## hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 blond fair blue ## 2 &lt;NA&gt; gold yellow ## 3 &lt;NA&gt; white, blue red ## 4 none white yellow ## 5 brown light brown ## 6 brown, grey light blue ## 7 brown light blue ## 8 &lt;NA&gt; white, red red ## 9 black light brown ## 10 auburn, white fair blue-gray ## # … with 77 more rows Or which start with the letter h: select(starwars, starts_with(&quot;h&quot;)) ## # A tibble: 87 x 3 ## height hair_color homeworld ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 172 blond Tatooine ## 2 167 &lt;NA&gt; Tatooine ## 3 96 &lt;NA&gt; Naboo ## 4 202 none Tatooine ## 5 150 brown Alderaan ## 6 178 brown, grey Tatooine ## 7 165 brown Tatooine ## 8 97 &lt;NA&gt; Tatooine ## 9 183 black Tatooine ## 10 182 auburn, white Stewjon ## # … with 77 more rows If you are familiar with regular expressions, you can also use them within the matches function: select(starwars, matches(&quot;^h&quot;)) # same as starts_with(&quot;h&quot;) ## # A tibble: 87 x 3 ## height hair_color homeworld ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 172 blond Tatooine ## 2 167 &lt;NA&gt; Tatooine ## 3 96 &lt;NA&gt; Naboo ## 4 202 none Tatooine ## 5 150 brown Alderaan ## 6 178 brown, grey Tatooine ## 7 165 brown Tatooine ## 8 97 &lt;NA&gt; Tatooine ## 9 183 black Tatooine ## 10 182 auburn, white Stewjon ## # … with 77 more rows Finally, you can select columns which name match a numerical range with num_range. For example, let’s take the billboard dataset that contains column names wk1, wk2, wk3 … up to wk76, and select only columns from wk18 to wk22: select(billboard, num_range(&quot;wk&quot;, 18:22)) ## # A tibble: 317 x 5 ## wk18 wk19 wk20 wk21 wk22 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA NA NA NA NA ## 2 NA NA NA NA NA ## 3 18 18 14 12 7 ## 4 67 73 70 NA NA ## 5 96 NA NA NA NA ## 6 84 93 94 NA NA ## 7 NA NA NA NA NA ## 8 67 83 86 NA NA ## 9 2 3 4 5 5 ## 10 71 79 89 NA NA ## # … with 307 more rows "],["filter.html", "7.3 filter", " 7.3 filter filter() is used to filter rows in a data frame / tibble. Keep rows if Democratic is found in column party: name start end party Eisenhower 1953-01-20 1961-01-20 Republican Kennedy 1961-01-20 1963-11-22 Democratic Johnson 1963-11-22 1969-01-20 Democratic Nixon 1969-01-20 1974-08-09 Republican Ford 1974-08-09 1977-01-20 Republican Carter 1977-01-20 1981-01-20 Democratic Reagan 1981-01-20 1989-01-20 Republican Bush 1989-01-20 1993-01-20 Republican Clinton 1993-01-20 2001-01-20 Democratic Bush 2001-01-20 2009-01-20 Republican Obama 2009-01-20 2017-01-20 Democratic filter(presidential, party==&quot;Democratic&quot;) ## # A tibble: 5 x 4 ## name start end party ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; ## 1 Kennedy 1961-01-20 1963-11-22 Democratic ## 2 Johnson 1963-11-22 1969-01-20 Democratic ## 3 Carter 1977-01-20 1981-01-20 Democratic ## 4 Clinton 1993-01-20 2001-01-20 Democratic ## 5 Obama 2009-01-20 2017-01-20 Democratic You can filter using several variables/columns: filter(presidential, party==&quot;Republican&quot;, name==&quot;Bush&quot;) # This implicity uses the &quot;&amp;&quot;, i.e. the fact that both conditions have to be TRUE filter(presidential, party==&quot;Republican&quot; &amp; name==&quot;Bush&quot;) # Any logical operators can be used filter(presidential, name %in% c(&quot;Bush&quot;, &quot;Kennedy&quot;)) The same can be used for numerical values: let’s select all rows from table5 where century &gt; 19: filter(table5, century &gt; 19) ## # A tibble: 3 x 4 ## country century year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 20 00 2666/20595360 ## 2 Brazil 20 00 80488/174504898 ## 3 China 20 00 213766/1280428583 HANDS-ON Going back to our previously create starwarsBMI data frame: How many characters have a BMI &gt; 30? How many characters have a BMI &gt; 30 AND are Droids (“Droid” in column species)? From the previous selection (BMI &gt; 30 and Droid), select columns BMI, character_name, height and mass, and save in the new object DroidBMI30. Answer # How many characters have a BMI &gt; 30? filter(starwarsBMI, BMI &gt; 30) # How many characters have a BMI &gt; 30 AND are Droids (&quot;Droid&quot; in column &quot;species&quot;)? filter(starwarsBMI, BMI &gt; 30 &amp; species==&quot;Droid&quot;) # From the previous selection (BMI &gt; 30 and Droid), select columns BMI, character_name, height and mass, and save in the new object DroidBMI30. DroidBMI30 &lt;- starwarsBMI %&gt;% filter(BMI &gt; 30 &amp; species==&quot;Droid&quot;) %&gt;% select(BMI, character_name, height, mass) "],["summarise-group-by.html", "7.4 summarise &amp; group_by", " 7.4 summarise &amp; group_by summarise collapses a data frame to a 1-row tibble (base R equivalent of aggregate()) Get average length of terms: summarise(presidential2, mean(duration_days)) ## # A tibble: 1 x 1 ## `mean(duration_days)` ## &lt;drtn&gt; ## 1 2125.091 days Get average length of terms + count of the total of entries: summarise(presidential2, mean(duration_days), n()) ## # A tibble: 1 x 2 ## `mean(duration_days)` `n()` ## &lt;drtn&gt; &lt;int&gt; ## 1 2125.091 days 11 You can also give a name to each of the calculations you produce with summarise (and add more calculations!): summarise(presidential2, mean_term=mean(duration_days), min_term=min(duration_days), max_term=max(duration_days), count_presidents=n()) ## # A tibble: 1 x 4 ## mean_term min_term max_term count_presidents ## &lt;drtn&gt; &lt;drtn&gt; &lt;drtn&gt; &lt;int&gt; ## 1 2125.091 days 895 days 2922 days 11 You can combine summarise with group_by to get, for example, the number of presidents per political party: group_by defines a grouping based on existing variables. summarise then processes the command based on the grouping # group based on the &quot;party&quot; column (that contains &quot;Democratic&quot; or &quot;Republican&quot;) groups &lt;- group_by(presidential2, party) # count the number of presidents per party: summarise(groups, n()) ## # A tibble: 2 x 2 ## party `n()` ## * &lt;chr&gt; &lt;int&gt; ## 1 Democratic 5 ## 2 Republican 6 # One line, using the %&gt;% operator: group_by(presidential2, party) %&gt;% summarise(n()) ## # A tibble: 2 x 2 ## party `n()` ## * &lt;chr&gt; &lt;int&gt; ## 1 Democratic 5 ## 2 Republican 6 Note: the row above is equivalent to using count (a wrapper): count(presidential, party) count(presidential2, party) ## # A tibble: 2 x 2 ## party n ## * &lt;chr&gt; &lt;int&gt; ## 1 Democratic 5 ## 2 Republican 6 Use the same structure to calculate the average length of terms per political party: group_by(presidential2, party) %&gt;% summarise(mean(duration_days)) ## # A tibble: 2 x 2 ## party `mean(duration_days)` ## * &lt;chr&gt; &lt;drtn&gt; ## 1 Democratic 2045.4 days ## 2 Republican 2191.5 days Note that you can group using more than one variable: group_by(starwars, species, hair_color, gender) %&gt;% summarise(n()) Grouping variables also influences how other dplyr functions work! For example, let’s group our starwars characters by both species and gender variables: sw_sg &lt;- group_by(starwars, species, gender) We can then use slice_max (function that retrieves the row that contains the maximum value in a selected variable) to retrieve the character with the maximum height: sw_sg %&gt;% select(name, species, gender, height) %&gt;% # columns selection just to make the output more readable slice_max(height) ## # A tibble: 43 x 4 ## # Groups: species, gender [42] ## name species gender height ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Ratts Tyerell Aleena masculine 79 ## 2 Dexter Jettster Besalisk masculine 198 ## 3 Ki-Adi-Mundi Cerean masculine 198 ## 4 Mas Amedda Chagrian masculine 196 ## 5 Zam Wesell Clawdite feminine 168 ## 6 R4-P17 Droid feminine 96 ## 7 IG-88 Droid masculine 200 ## 8 Sebulba Dug masculine 112 ## 9 Wicket Systri Warrick Ewok masculine 88 ## 10 Poggle the Lesser Geonosian masculine 183 ## # … with 33 more rows We get one entry for each unique combination of species and gender. If you query the maximum height on an non-grouped tibble, you will get only one row (maximum height overall): starwars %&gt;% select(name, species, gender, height) %&gt;% slice_max(height) ## # A tibble: 1 x 4 ## name species gender height ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Yarael Poof Quermian masculine 264 Another example is that you can create new columns (with mutate) based on the grouping. Here we are grouping the data by species and we add a column average_height_species that describes the average height. As the data is grouped by species, we will get the average height PER SPECIES: starwars %&gt;% group_by(species) %&gt;% select(name, species, height, mass) %&gt;% mutate(average_height_species=mean(height, na.rm=TRUE)) ## # A tibble: 87 x 5 ## # Groups: species [38] ## name species height mass average_height_species ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Luke Skywalker Human 172 77 177. ## 2 C-3PO Droid 167 75 131. ## 3 R2-D2 Droid 96 32 131. ## 4 Darth Vader Human 202 136 177. ## 5 Leia Organa Human 150 49 177. ## 6 Owen Lars Human 178 120 177. ## 7 Beru Whitesun lars Human 165 75 177. ## 8 R5-D4 Droid 97 32 131. ## 9 Biggs Darklighter Human 183 84 177. ## 10 Obi-Wan Kenobi Human 182 77 177. ## # … with 77 more rows HANDS-ON Back to our starwarsBMI tibble: Count the number of occurrences of each hair color per gender. Count the average BMI per species. Add a count of the number of individuals per species. Answer # Count the number of occurrences of each `hair color` per `gender` starwarsBMI %&gt;% group_by(gender, hair_color) %&gt;% summarise(mycounts=n()) # Count the average **BMI** per `species`. Add a count of the number of individuals per species. starwarsBMI %&gt;% group_by(species) %&gt;% summarise(average_bmi=mean(BMI, na.rm=TRUE), count_individuals=n()) # Also report the number of individuals for which BMI is NOT NA (i.e. the actual number of individuals for which the average was computed) starwarsBMI %&gt;% group_by(species) %&gt;% summarise(average_bmi=mean(BMI, na.rm=TRUE), count_all_individuals=n(), count_individuals_non_NA=sum(!is.na(BMI))) 7.4.1 ungroup When you are grouping variables with group_by, the tibble will keep the grouping until you ungroup! While this is not an issue when you are summarizing (you get a summary table), it can be useful in case you are using the grouping - for example - to create a new column. In the example stated before, we created a new column average_height_species that contains the average height per species: starwars %&gt;% group_by(species) %&gt;% select(name, species, height, mass) %&gt;% mutate(average_height_species=mean(height, na.rm=TRUE)) %&gt;% head(n=2) ## # A tibble: 2 x 5 ## # Groups: species [2] ## name species height mass average_height_species ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Luke Skywalker Human 172 77 177. ## 2 C-3PO Droid 167 75 131. What if we also want to add a column that describes the average mass of ALL individuals (regardless of the species)? # With the current grouping (species), you get the average mass calculated per species starwars %&gt;% group_by(species) %&gt;% select(name, species, height, mass) %&gt;% mutate(average_height_species=mean(height, na.rm=TRUE)) %&gt;% mutate(average_mass=mean(mass, na.rm=TRUE)) %&gt;% head(n=2) ## # A tibble: 2 x 6 ## # Groups: species [2] ## name species height mass average_height_species average_mass ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Luke Skywalker Human 172 77 177. 82.8 ## 2 C-3PO Droid 167 75 131. 69.8 Column average_mass still contains the average per species! * We need to ungroup the tibble before creating this new column!! # ungroup first, and you get the average mass calculated for the whole tibble starwars %&gt;% group_by(species) %&gt;% select(name, species, height, mass) %&gt;% mutate(average_height_species=mean(height, na.rm=TRUE)) %&gt;% ungroup %&gt;% mutate(average_mass=mean(mass, na.rm=TRUE)) %&gt;% head(n=2) ## # A tibble: 2 x 6 ## name species height mass average_height_species average_mass ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Luke Skywalker Human 172 77 177. 97.3 ## 2 C-3PO Droid 167 75 131. 97.3 "],["arrange.html", "7.5 arrange", " 7.5 arrange arrange orders the rows of a data frame by the values of selected columns. Let’s order rows by increasing mandate duration: arrange(presidential2, duration_days) ## # A tibble: 11 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Ford 1974-08-09 1977-01-20 Republican 895 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 4 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 5 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 6 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 7 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 8 Reagan 1981-01-20 1989-01-20 Republican 2922 days ## 9 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 10 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 11 Obama 2009-01-20 2017-01-20 Democratic 2922 days # decreasing order with arrange(presidential2, desc(duration_days)) You can use several columns for the sorting arrange(presidential2, duration_days, name) ## # A tibble: 11 x 5 ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Ford 1974-08-09 1977-01-20 Republican 895 days ## 2 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 3 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 4 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 5 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 6 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 7 Bush 2001-01-20 2009-01-20 Republican 2922 days ## 8 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 9 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 10 Obama 2009-01-20 2017-01-20 Democratic 2922 days ## 11 Reagan 1981-01-20 1989-01-20 Republican 2922 days If a grouping was done before, you can arrange first by grouping and then by selected variable(s) setting the .by_group=TRUE parameter: presidential2 %&gt;% group_by(party) %&gt;% arrange(duration_days, .by_group=TRUE) ## # A tibble: 11 x 5 ## # Groups: party [2] ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 2 Carter 1977-01-20 1981-01-20 Democratic 1461 days ## 3 Johnson 1963-11-22 1969-01-20 Democratic 1886 days ## 4 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 5 Obama 2009-01-20 2017-01-20 Democratic 2922 days ## 6 Ford 1974-08-09 1977-01-20 Republican 895 days ## 7 Bush 1989-01-20 1993-01-20 Republican 1461 days ## 8 Nixon 1969-01-20 1974-08-09 Republican 2027 days ## 9 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 10 Reagan 1981-01-20 1989-01-20 Republican 2922 days ## 11 Bush 2001-01-20 2009-01-20 Republican 2922 days HANDS-ON Go back to the previous exercise: “count the average BMI per species. Add a count of the number of individuals per species.” (on the starwarsBMI data set): starwarsBMI %&gt;% group_by(species) %&gt;% summarise(average_bmi=mean(BMI, na.rm=TRUE), count_individuals=n()) Keep only species that have 2 or more individuals. Arrange by decreasing average BMI. Answer starwarsBMI %&gt;% group_by(species) %&gt;% summarise(average_bmi=mean(BMI, na.rm=TRUE), count_individuals=n()) %&gt;% filter(count_individuals &gt;= 2) %&gt;% arrange(desc(average_bmi)) "],["a-few-more-useful-dplyr-functions.html", "7.6 A few more useful dplyr functions", " 7.6 A few more useful dplyr functions 7.6.1 Mutating joins The following functions allows one to join / merge 2 tibbles into 1 using columns that contain common keys. Table 7.4: mutating joins functions name what.it.does inner_join includes all rows in x and y (intersection) left_join includes all rows in x right_join includes all rows in y full_join includes all rows in x or y (union) Let’s create 2 small tibbles: tibX &lt;- tibble(ID=LETTERS[1:4], year=c(&quot;2020&quot;, &quot;2021&quot;, &quot;2021&quot;, &quot;2020&quot;) ) tibY &lt;- tibble(ID=LETTERS[3:5], month=c(&quot;January&quot;, &quot;October&quot;, &quot;July&quot;) ) We will join tibX and tibY using the ID column, and keep only rows that contain a matching ID with inner_join: inner_join(x=tibX, y=tibY, by=&quot;ID&quot;) ## # A tibble: 2 x 3 ## ID year month ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 C 2021 January ## 2 D 2020 October Keep all rows from tibX regardless on whether they have a match in tibY with left_join: left_join(x=tibX, y=tibY, by=&quot;ID&quot;) ## # A tibble: 4 x 3 ## ID year month ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A 2020 &lt;NA&gt; ## 2 B 2021 &lt;NA&gt; ## 3 C 2021 January ## 4 D 2020 October Keep all rows from tibY regardless on whether they have a match in tibX with right_join: right_join(x=tibX, y=tibY, by=&quot;ID&quot;) ## # A tibble: 3 x 3 ## ID year month ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 C 2021 January ## 2 D 2020 October ## 3 E &lt;NA&gt; July Keep all rows from both tibbles with full_join: full_join(x=tibX, y=tibY, by=&quot;ID&quot;) ## # A tibble: 5 x 3 ## ID year month ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A 2020 &lt;NA&gt; ## 2 B 2021 &lt;NA&gt; ## 3 C 2021 January ## 4 D 2020 October ## 5 E &lt;NA&gt; July Note that columns do NOT need to be named the same way! Let’s consider the new tibble tibZ: tibZ &lt;- tibble(id=LETTERS[3:5], month=c(&quot;May&quot;, &quot;June&quot;, &quot;April&quot;) ) We can join it with tibX by giving the “by” parameter a named vector that contains 1 element: full_join(x=tibX, y=tibZ, by=c(&quot;ID&quot; = &quot;id&quot;) ) ## # A tibble: 5 x 3 ## ID year month ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A 2020 &lt;NA&gt; ## 2 B 2021 &lt;NA&gt; ## 3 C 2021 May ## 4 D 2020 June ## 5 E &lt;NA&gt; April HANDS-ON Join the 2 following tibbles (keep all rows from the mynames tibble): mynames &lt;- tibble(name=c(&quot;Einstein&quot;, &quot;Newton&quot;, &quot;Curie&quot;, &quot;Mendel&quot;, &quot;Franklin&quot;), birth_year=c(1879, 1643, 1867, 1822, 1920)) myemails &lt;- tibble(full_name=c(&quot;Albert Einstein&quot;, &quot;Isaac Newton&quot;, &quot;Marie Curie&quot;, &quot;Rosalind Franklin&quot;), email_address=c(&quot;aeinstein283@coolmail.com&quot;, &quot;isaac.newton.scientist@coolmail.com&quot;, &quot;mariecurie007@coolmail.com&quot;, &quot;rosalind2_franklin@coolmail.com&quot;)) Answer # need to separate a column first! myemails %&gt;% separate(col=full_name, into=c(&quot;first_name&quot;, &quot;last_name&quot;), sep=&quot; &quot;) %&gt;% right_join(y=mynames, by=c(&quot;last_name&quot; = &quot;name&quot;)) 7.6.2 Extract or remove rows with slice: Extract rows: # Fetch the first 2 rows (index 1 and 2) slice(presidential2, 1:2) Remove rows: # Remove 1rst and 4th rows slice(presidential2, -c(1,4)) The slice helpers can be useful: Table 7.5: slice helpers name usage slice_min select rows with lowest values of a variable slice_max select rows with highest values of a variable slice_head select the first rows slice_tail select the last rows slice_sample randomly select rows Extract the row that has the maximum height from in the starwars dataset with slice_max: # by default, only 1 row is extracted slice_max(starwars, order_by=height) ## # A tibble: 1 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Yarae… 264 NA none white yellow NA male mascu… Quermia Quermi… ## # … with 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; # set parameter &quot;n&quot; if you want to extract the &quot;n&quot; top rows slice_max(starwars, order_by=height, n=3) ## # A tibble: 3 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Yarae… 264 NA none white yellow NA male mascu… Quermia Quermi… ## 2 Tarff… 234 136 brown brown blue NA male mascu… Kashyyyk Wookiee ## 3 Lama … 229 88 none grey black NA male mascu… Kamino Kamino… ## # … with 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Same for the minimum with slice_min: slice_min(starwars, order_by=mass, n=2) ## # A tibble: 2 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Ratts… 79 15 none grey, blue unknown NA male mascu… Aleen Mi… Aleena ## 2 Yoda 66 17 white green brown 896 male mascu… &lt;NA&gt; Yoda&#39;s… ## # … with 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Extract the first or last row with slice_head and slice_tail, respectively # first row slice_head(starwars) ## # A tibble: 1 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke … 172 77 blond fair blue 19 male mascu… Tatooine Human ## # … with 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; # last row slice_tail(starwars) ## # A tibble: 1 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Padmé… 165 45 brown light brown 46 fema… femin… Naboo Human ## # … with 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; You can extract the “n” first or last rows, or you can extract a certain proportions of rows to select with “prop”: # first 5 rows slice_head(starwars, n=5) # first 10% of the rows slice_head(starwars, prop=0.1) # last 7 rows slice_tail(starwars, n=7) # last 25% of the rows slice_tail(starwars, prop=0.25) Select a random sample of rows with slice_random: # 1 random row slice_sample(starwars) ## # A tibble: 1 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Plo K… 188 80 none orange black 22 male mascu… Dorin Kel Dor ## # … with 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; # 4 random rows slice_sample(starwars, n=4) ## # A tibble: 4 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Taun … 213 NA none grey black NA fema… femin… Kamino Kamino… ## 2 Gasga… 122 NA none white, bl… black NA male mascu… Troiken Xexto ## 3 Grega… 185 85 black dark brown NA male mascu… Naboo Human ## 4 Saese… 188 NA none pale orange NA male mascu… Iktotch Iktotc… ## # … with 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; # 3% of rows selected randomly slice_sample(starwars, prop=0.03) ## # A tibble: 2 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Plo K… 188 80 none orange black 22 male mascu… Dorin Kel Dor ## 2 Clieg… 183 NA brown fair blue 82 male mascu… Tatooine Human ## # … with 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Note that the slice functions can be combined with a grouping. With slice_max you would get the maximum per group (with slice_min, the minimum per group): presidential2 %&gt;% group_by(party) %&gt;% slice_max(order_by = duration_days) ## # A tibble: 5 x 5 ## # Groups: party [2] ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Clinton 1993-01-20 2001-01-20 Democratic 2922 days ## 2 Obama 2009-01-20 2017-01-20 Democratic 2922 days ## 3 Eisenhower 1953-01-20 1961-01-20 Republican 2922 days ## 4 Reagan 1981-01-20 1989-01-20 Republican 2922 days ## 5 Bush 2001-01-20 2009-01-20 Republican 2922 days presidential2 %&gt;% group_by(party) %&gt;% slice_min(order_by = duration_days) ## # A tibble: 2 x 5 ## # Groups: party [2] ## name start end party duration_days ## &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;chr&gt; &lt;drtn&gt; ## 1 Kennedy 1961-01-20 1963-11-22 Democratic 1036 days ## 2 Ford 1974-08-09 1977-01-20 Republican 895 days 7.6.3 Extract a single column as a vector with pull: # extract column &quot;duration_days&quot; presidential2 %&gt;% pull(duration_days) ## Time differences in days ## [1] 2922 1036 1886 2027 895 1461 2922 1461 2922 2922 2922 # extract column &quot;duration_days&quot; as a vector, and name the vector using the &quot;name&quot; column presidential2 %&gt;% pull(duration_days, name=name) ## Time differences in days ## Eisenhower Kennedy Johnson Nixon Ford Carter Reagan Bush ## 2922 1036 1886 2027 895 1461 2922 1461 ## Clinton Bush Obama ## 2922 2922 2922 7.6.4 Change column order with relocate: # move column &quot;party&quot; as the start relocate(presidential, party) # move column &quot;name&quot; before column &quot;party&quot; relocate(presidential, party, .before=party) # move column &quot;name&quot; at the end (after last column) relocate(presidential, name, .after=last_col()) # move around all columns relocate(presidential, party, start, name, end) # rename a column as you relocate it relocate(presidential, President=name, .after=last_col()) # reorganize columns alphabetically relocate(presidential, sort(tidyselect::peek_vars())) "],["exercise.html", "7.7 Exercise", " 7.7 Exercise We will work with a modified version of the storms data set: positions and attributes of 198 tropical storms, measured every 6 hours. Download and read in this file (using a tidyverse function!): store the dataset into object mystorms, and then tidy it! What storm has the highest median wind speed? Calculate how many storms happen each year. You might need to separate a column… And check how the distinct function can help you! What are the years with the maximum number of storms? Answer # 1. download, read in, tidy mystorms &lt;- read_csv(&quot;https://public-docs.crg.es/biocore/projects/training/R_tidyverse_2021/modified_storms.csv&quot;) %&gt;% separate(col=wind_and_pressure, into=c(&quot;wind&quot;, &quot;pressure&quot;), sep=&quot;-&quot;, convert=TRUE) # 2. What storm has the highest median wind speed? mystorms %&gt;% group_by(name) %&gt;% summarise(median_wind = median(wind)) %&gt;% slice_max(order_by=median_wind) # 3. Calculate how many storms happen each year: mystorms %&gt;% separate(date, into=c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), sep=&quot;-&quot;) %&gt;% distinct(name, year) %&gt;% group_by(year) %&gt;% summarise(storms_per_year=n()) # What are the years with the **maximum** number of storms? mystorms %&gt;% separate(date, into=c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), sep=&quot;-&quot;) %&gt;% distinct(name, year) %&gt;% group_by(year) %&gt;% summarise(storms_per_year=n()) %&gt;% slice_max(order_by=storms_per_year, n=5) "],["handling-missing-values.html", "Part 8 Handling missing values", " Part 8 Handling missing values drop_na: drop rows containing missing values. Create a tibble that contains missing (NA) values: dfwithNA &lt;- tibble(x = c(1, 2, NA, 5), y = c(&quot;a&quot;, NA, &quot;b&quot;, &quot;c&quot;)) Remove rows that contain NA values with drop_na: drop_na(dfwithNA) ## # A tibble: 2 x 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 5 c replace_na: change NA values to a selected value (one per column): # replace NAs by 0s in column &quot;x&quot;, and by &quot;k&quot; in column &quot;y&quot; replace_na(dfwithNA, list(x=0, y=&quot;k&quot;)) ## # A tibble: 4 x 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 k ## 3 0 b ## 4 5 c complete: turns implicit missing values into explicit missing values: df &lt;- tibble( patient = c(&quot;Patient1&quot;, &quot;Patient1&quot;, &quot;Patient2&quot;, &quot;Patient3&quot;, &quot;Patient3&quot;), treatment = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;), value1 = 1:5, value2 = 4:8 ) Here we are missing a row for Patient2 / Treatment B: add it and fill in with NA values: complete(df, patient, treatment) # columns to expand ## # A tibble: 6 x 4 ## patient treatment value1 value2 ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Patient1 A 1 4 ## 2 Patient1 B 2 5 ## 3 Patient2 A 3 6 ## 4 Patient2 B NA NA ## 5 Patient3 A 4 7 ## 6 Patient3 B 5 8 If you want implicit missing values to be filled by something else than NA, use the fill parameter: # we will fill in missing values with 0s in column &quot;value1&quot;, and with NAs in column &quot;value2&quot; complete(df, patient, treatment, fill=list(value1=0, value2=NA)) ## # A tibble: 6 x 4 ## patient treatment value1 value2 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Patient1 A 1 4 ## 2 Patient1 B 2 5 ## 3 Patient2 A 3 6 ## 4 Patient2 B 0 NA ## 5 Patient3 A 4 7 ## 6 Patient3 B 5 8 In practice: what if you have NA values, along with empty cells and “customized” missing values? dfwithNA2 &lt;- tibble(col1=c(1, 2, NA, 5, &quot;&quot;, 4), col2=c(&quot;a&quot;, NA, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;missing&quot;)) Replace empty cells and “customized” missing values with NA with na_if: dfwithNA2 %&gt;% mutate(col1=na_if(col1, &quot;&quot;), col2=na_if(col2, &quot;missing&quot;)) ## # A tibble: 6 x 2 ## col1 col2 ## &lt;chr&gt; &lt;chr&gt; ## 1 1 a ## 2 2 &lt;NA&gt; ## 3 &lt;NA&gt; b ## 4 5 c ## 5 &lt;NA&gt; d ## 6 4 &lt;NA&gt; HANDS-ON Back to the starwars data set: Replace NA in hair_color with “unknown.” Remove rows that still contain NA values. Answer # Replace NA in `hair_color` with &quot;unknown&quot;. # Remove rows that still contain NA values. replace_na(starwars, list(hair_color=&quot;unknown&quot;)) %&gt;% drop_na() "],["strings-manipulation-with-stringr.html", "Part 9 Strings manipulation with stringr", " Part 9 Strings manipulation with stringr The stringr package provides tools for string manipulation. All functions in stringr start with str_ and take a vector of strings as the first argument. We will show here a few useful functions (for a complete list of stringr functions, you can have a look at the Cheat sheet. The cheat sheet also provides guidance on how to work with regular expressions. Let’s take a simple character vector and a small tibble as examples: examplestring &lt;- c(&quot;genomics&quot;, &quot;proteomics&quot;, &quot;proteome&quot;, &quot;transcriptomics&quot;, &quot;metagenomics&quot;, &quot;metabolomics&quot;) exampletibble &lt;- tibble(day=c(&quot;day0&quot;, &quot;day1&quot;, &quot;day2&quot;), temperature=c(&quot;25C&quot;, &quot;27C&quot;, &quot;24Celsius&quot;)) str_detect: detects the presence or absence of a pattern in a string. str_detect(examplestring, pattern=&quot;genom&quot;) ## [1] TRUE FALSE FALSE FALSE TRUE FALSE You can use regular expressions: as a simple example, here we want to detect which element of examplestring starts with genom. str_detect(examplestring, pattern=&quot;^genom&quot;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE You can reverse the search and output elements where the pattern is NOT found with negate=TRUE str_detect(examplestring, pattern=&quot;genom&quot;, negate=TRUE) ## [1] FALSE TRUE TRUE TRUE FALSE TRUE str_length: outputs length of strings (number of characters) in each element of a vector. str_length(examplestring) ## [1] 8 10 8 15 12 12 str_replace: looks for a pattern in a string and replace it. We can replace “omics” with “ome” str_replace(examplestring, pattern=&quot;omics&quot;, &quot;ome&quot;) ## [1] &quot;genome&quot; &quot;proteome&quot; &quot;proteome&quot; &quot;transcriptome&quot; &quot;metagenome&quot; ## [6] &quot;metabolome&quot; str_replace can be used to remove selected patterns from strings: str_replace(examplestring, pattern=&quot;omics&quot;, &quot;&quot;) ## [1] &quot;gen&quot; &quot;prote&quot; &quot;proteome&quot; &quot;transcript&quot; &quot;metagen&quot; &quot;metabol&quot; # str_remove is a wrapper for the same thing (no need for the 3rd argument) str_remove(examplestring, pattern=&quot;omics&quot;) ## [1] &quot;gen&quot; &quot;prote&quot; &quot;proteome&quot; &quot;transcript&quot; &quot;metagen&quot; &quot;metabol&quot; Same with a tibble’s column: str_remove(exampletibble$day, pattern=&quot;day&quot;) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; You can use it inside another tidyverse function: mutate(exampletibble, day=str_remove(day, pattern=&quot;day&quot;)) ## # A tibble: 3 x 2 ## day temperature ## &lt;chr&gt; &lt;chr&gt; ## 1 0 25C ## 2 1 27C ## 3 2 24Celsius str_count: count the number of occurences of a pattern: Count how many times “omics” is found in each element: str_count(examplestring, pattern=&quot;omics&quot;) ## [1] 1 1 0 1 1 1 Count how many vowels are found in each element: str_count(examplestring, pattern=&quot;[aeiouy]&quot;) ## [1] 3 4 4 4 5 5 str_sub: extracts and replace substrings from a character vector str_sub(examplestring, start=1, # position of the first character end=10) # position of the last character ## [1] &quot;genomics&quot; &quot;proteomics&quot; &quot;proteome&quot; &quot;transcript&quot; &quot;metagenomi&quot; &quot;metabolomi&quot; Let’s keep the first 2 characters of the temperature column of our exampletibble: str_sub(exampletibble$temperature, start=1, end=2) ## [1] &quot;25&quot; &quot;27&quot; &quot;24&quot; Within mutate: mutate(exampletibble, temperature=str_sub(temperature, start=1, end=2)) ## # A tibble: 3 x 2 ## day temperature ## &lt;chr&gt; &lt;chr&gt; ## 1 day0 25 ## 2 day1 27 ## 3 day2 24 HANDS-ON We will play with the following character vector: countries &lt;- c(&quot;Germany&quot;, &quot;Uganda&quot;, &quot;Canada&quot;, &quot;Australia&quot;, &quot;Switzerland&quot;, &quot;Thailand&quot;, &quot;Bolivia&quot;, &quot;Russia&quot;, &quot;Italy&quot;, &quot;Senegal&quot;, &quot;South Korea&quot;, &quot;Mexico&quot;, &quot;Argentina&quot;, &quot;England&quot;) What is the average length of the country names? How many country names end with an “a”? Replace empty spaces with underscores in countries. In which country name do you find more the letter “a”? Answer # What is the average length of the country names? mean(str_length(countries)) # How many country names end with an &quot;a&quot;? # Get the logical vector str_detect(countries, &quot;a$&quot;) # Retrieve only the &quot;TRUE&quot; and count length(which(str_detect(countries, &quot;a$&quot;))) length(countries[str_detect(countries, &quot;a$&quot;)]) # Replace empty spaces with underscores in `countries`. str_replace(countries, &quot; &quot;, &quot;_&quot;) # In which country name do you find more the letter &quot;a&quot;? # count how many &quot;a&quot; per country name str_count(countries, &quot;a&quot;) # extract the country name where there are more &quot;a&quot;. countries[max(str_count(countries, &quot;a&quot;))] "],["mini-project.html", "Part 10 Mini project", " Part 10 Mini project We will work with two input files: annotation.tsv: contains the annotation (from Gencode) of 29244 Human genes. normalized_counts.csv: contains the log2-transformed normalized counts from an RNA-seq project. The expression of 14769 Human genes in 8 samples from 4 experimental groups is assessed: Treatment 1, time 0 (2 samples) Treatment 1, time 20 (2 samples) Treatment 2, time 0 (2 samples) Treatment 2, time 20 (2 samples) Download / read in the two files that are found here into two tibbles. # Download and read in the files annotation &lt;- read_tsv(&quot;https://public-docs.crg.es/biocore/projects/training/R_tidyverse_2021/mini_project/annotation.tsv&quot;) norm_data &lt;- read_csv(&quot;https://public-docs.crg.es/biocore/projects/training/R_tidyverse_2021/mini_project/normalized_counts.csv&quot;) Tidy each tibble individually. Some tips! For the annotation: something needs to be separated. For the normalized data: it’s important to pivot some columns… And to separate one created by the pivoting! # Separate the &quot;gene_name_gene_type&quot; column into gene_name and gene_type annotation_tidy &lt;- annotation %&gt;% separate(col=gene_name_gene_type, into=c(&quot;gene_name&quot;, &quot;gene_type&quot;), sep=&quot;/&quot;) # Pivot the data so there is a single column for the expression value # Use separate to create 3 new columns that will contain information, respectively on: Treatment, replicate, time point. # (optional) mutate the &quot;time&quot; column to get a numeric column that contains only the actual time point (without the &quot;t&quot;) norm_data_tidy &lt;- norm_data %&gt;% pivot_longer(cols=contains(&quot;Treatment&quot;), values_to=&quot;expression&quot;, names_to=&quot;samples&quot;) %&gt;% separate(col=samples, into=c(&quot;Treatment&quot;, &quot;replicate&quot;, &quot;time&quot;), sep=&quot;_&quot;) %&gt;% mutate(time=as.numeric(str_remove(time, &quot;t&quot;))) Join both datasets so as to obtain one tibble (keep the intersection). Don’t know which columns to use for the joining? Click here for help! Work on the gencode_id column of the normalized data: Gencode IDs only differ from the Ensembl IDs by the suffix (point + numbers). e.g. ENSG00000140853.15 in Gencode is ENSG00000140853 in Ensembl. Perhaps str_sub can help? # First, we need a common ID: remove the suffix with the point + numbers from &quot;gencode_id&quot; in order to obtain &quot;ensembl&quot; IDs norm_data_tidy &lt;- norm_data_tidy %&gt;% mutate(ensembl_gene_id=str_sub(gencode_id, 1, 15), .before=Treatment) # not important, just more convenient # Use inner join in order to keep only common data all_data &lt;- inner_join(x=annotation_tidy, y=norm_data_tidy, by=&quot;ensembl_gene_id&quot;) What is the average expression of the different types of genes (gene_type)? According to this data, which 2 gene types have the highest average expression? Remove all rows which correspond to these 2 gene types from the dataset. What is now the size of our dataset? A couple of tips… Remember slice_max? pull could also be useful! highest_mean_2types &lt;- all_data %&gt;% group_by(gene_type) %&gt;% summarise(average_mean_gene_type=mean(expression)) %&gt;% slice_max(order_by=average_mean_gene_type, n=2) %&gt;% pull(gene_type) data_no_highest_2types &lt;- all_data %&gt;% filter(!gene_type %in% highest_mean_2types) dim(data_no_highest_2types) Create a new column that contains the median expression per gene, per experimental group and per gene type. By experimental group, we mean Treatment + time (for example, samples “Treatment1_rep1_t0” and “Treatment1_rep2_t0” are part of the same experimental group: Treatment1_t0) Help! If you don’t have it already, create a column experimental_group. The grouping should be done using 3 variables. Remember that, if the data is grouped, the newly created columns will take into account the groups… # New column for the actual experimental group (no &quot;rep1&quot; and &quot;rep2&quot;) # group_by gene_name, gene_type and experimental_group data_no_highest_2_types &lt;- data_no_highest_2types %&gt;% unite(col=&quot;experimental_group&quot;, Treatment, time, sep=&quot;_&quot;) %&gt;% group_by(experimental_group, gene_type, gene_name) %&gt;% mutate(median_expression_experimental_group=median(expression)) For each experimental group, retrieve the lincRNA that has the highest median expression. Is it the same lincRNA gene for all 4 experimental groups? Stuck? Click here. Check this stackoverflow post for inspiration. data_no_highest_2_types %&gt;% ungroup() %&gt;% group_by(experimental_group, gene_type) %&gt;% filter(expression == max(expression) &amp; gene_type==&quot;lincRNA&quot;) "],["references-and-resources.html", "Part 11 References and resources", " Part 11 References and resources Main sources for building this course: R for Data Science from Hadley Wickham &amp; Garrett Grolemund. Tidyverse documentation. The course’s material was made using bookdown More resources: RStudio Cheat sheets Course on computing for the social sciences Wrangling penguins: some basic data wrangling in R with dplyr Be awesome in ggplot2 "]]
