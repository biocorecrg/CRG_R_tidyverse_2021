# Tidy data with `tidyr`

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE)
```

## What is "tidy" data?

**Tidy** data is where:

* Each **column** describes a **variable**.
* Each **row** describes an **observation**.
* Each **value** is a **cell**.

```{r, echo=FALSE, out.width="100%", fig.cap="Tidy data. [Source](https://garrettgman.github.io/images/tidy-1.png)"}
knitr::include_graphics("images/tidy_data.png")
```


Example of a tidy data:

| day | month  | year  |  weight |  height |
|:---:|:---:|:---:|:---:|:---:|
| 12 | 4  | 2020  |  3.5 |  48 |
| 23 |  8 | 2019  | 2.9  |  50 |
| 9 |  11 | 2020  | 3.8  |  50 |

<br>
Example of untidy data:

| day | month,year  |  weight |  height |
|:---:|:---:|:---:|:---:|
| 12 | 4,2020  |  3.5kg |  48 |
| 23 |  8,2019  | 2.9kg  |  50 |
| 9 |  11,2020  | 3.8kg  |  50 |

Here we introduce some useful functions from the `tidyr` package to clean up and organize data so as to obtain **tidy** data that can then be processed more easily.
<br>



## Separate & Unite

Let's work on the **untidy** tibble **`table5`** that is a built-in data set from the `tidyr` package *(table5 displays the number of tuberculosis cases documented by the WHO in selected countries)*:


```{r, echo=F}
knitr::kable(table5, caption ="`table5`")
```

### Separate

Function `separate` separates (indeed!) a column into 2 or more columns: `separate(data, col, into, sep)`

```{r}
# separate column "rate" into 2 columns that we name cases and population, based on the "/" separator.
table5_1 <- separate(data=table5, 
         col=rate, 
         into=c("cases", "population"),
         sep="/"
         )

table5_1
```

### Unite

Function `unite` does just the opposite: it will unite/stick together 2 or (more) columns: `unite(data, col, column names, sep)`.

```{r}
# unite columns "century" and "year"
table5a_2 <- unite(data=table5_1,
                col=year,
                c("century", "year"), 
                sep="")

table5a_2
```

<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>

Fix the following untidy `tibble`:

```{r}
patients <- tibble(
  ID1=c("A", "A", "B", "B"),
  ID2=c(12, 13, 14, 15),
  age=c( 21,  32, 25, 43),
  c("188_93", "167_55", "155_51", "175_72")
)
```

* Separate the two variables that are found in the last column into columns **height** and **weight**: save in object `patients2`.
* Unite columns **ID1** and **ID2** so as to create a unique **ID** per patient: save in `patients3`.

<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r}
# Separate the two variables that are found in the last column.
patients2 <- separate(data=patients, 
         col=4,
         into=c("height", "weight"),
         sep="_")

# Unite columns ID1 and ID2 so as to create a unique ID per patient.
patients3 <- unite(data=patients2,
      col="ID",
      c("ID1", "ID2"),
      sep="")
```

</details>

* Is there a problem with `patients3`? Display the tibble in the R console...

Columns `height` and `weight` are **treated as characters** (because they originally contained **underscores** "_" !).
<br> 
We can convert them into numbers with the `mutate_at` function from the `dplyr` package: try it!

<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r}
# first argument: the tibble
# second argument: a vector of column names to mutate
# third argument: how to mutate those columns
patients4 <- mutate_at(patients3, 
                       c("height", "weight"), 
                       as.numeric)
```

</details>


## Pivoting data

The examples above were obvious untidy (two values in one cell, date in t2o different columns).
<br>
It will happen that the format of the data you are usually working with is NOT tidy.

<br>
Example: here we create a tibble that contains the expression of 4 genes in 4 samples:

```{r, eval=T}
df_expr <- tibble(gene=c("Fgfrl1", "Usp34", "Mlf2", "Gga1"),
                KO_t0=1:4,
                KO_t10=5:2,
                WT_t0=6:3,
                WT_t10=0:3
                )
```

**Why can't this tibble be considered `tidy`?**
<br>
* One variable (expression) is spread across 4 columns.

In order to fix this, we can use the `pivot_longer` function: we will increase the number of rows and decreases the number of columns:

```{r}
pivot_longer(df_expr,
             cols=c("KO_t0", "KO_t10", "WT_t0", "WT_t10")
)
```

Now **only one column**, column `value` contains the expression variable..

```{r}
expr_long <- pivot_longer(df_expr,
             cols=c("KO_t0", "KO_t10", "WT_t0", "WT_t10"),
             values_to="expression",
             names_to="sample"
)
```

Is there anything else wrong here, to make the data **tidy**?

* There are 2 variables in column `sample`: samples experimental group (KO or WT) and time point (t0 and t10): we can `separate` them.

```{r}
# we can add "remove=FALSE" so as to keep the original column (sample name) that can be useful
expr_tidy <- separate(expr_long,
              col=sample, 
              into=c("group", "time"),
              sep="_",
              remove=FALSE
         )    
```


`pivot_wider` does just the opposite: when an observation is scattered across multiple rows, you can move it back to a column.
<br> 
```{r}
df_expr2 <- tibble(gene=c(rep("Fgfrl1", 4), rep("Mlf2", 4)),
                group=rep(rep(c("KO", "WT"), each=2), 2),
                type=rep(c("counts_rnaseq", "Ct_qpcr"), 4),
                value=c(10, 25, 8, 22, 7, 23, 11, 28)
                )

```

Here, it would make sense to have a column `counts_rnaseq` and a column `Ct_qpcr`, which would contain their corresponding values.


df_expr2_wider <- pivot_wider(df_expr2,
                        names_from=type, 
                        values_from=value)

