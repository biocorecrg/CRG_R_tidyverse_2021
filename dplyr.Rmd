# Data manipulation

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE)
```

Package `dplyr` introduces a grammar of data manipulation. [Cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf)
<br>

We will first introduce the **5 intuitively-named key functions** from **{dplyr}**:

* **mutate()** adds new variables (columns) that are functions of existing variables
* **select()** picks variables (columns) based on their names.
* **filter()** picks observations (rows) based on their values.
* **summarise()** collapses multiple values down to a single summary.
* **arrange()** changes the ordering of the rows.

<br>

All 5 functions work in a similar and consistent way:

* The first argument is a **data frame** or a **tibble**.
* The result is a new data frame.
 
> *Note that {dplyr} never modifies the input: you need to* ***redirect the output*** *and save in a new - or the same - object.*

<br><br> 
We will use the `presidential` data set.
*It contains data of the terms of* ***presidents of the USA***, *from Eisenhower to Obama:*

* Name
* Term starting date
* Term ending date of mandate
* Political party
 
```{r, echo=F, warning=F, message=F}
library(kableExtra)
knitr::kable(presidential, caption="`presidential` data set")
```


## mutate & transmute

`mutate` allows to create new columns that are functions of the existing ones.

* Create a new column with the duration of each term:


```{r, eval=FALSE}
# Subtracting column start to colum end
mutate(presidential, 
    duration_days=end - start)
```

Notes:

* Use **unquoted** column names.
* Columns are added at the end of the data frame.
* `mutate` keeps all columns. 

If you want to keep only the **newly created column(s)** (drop the remaining ones): use `transmute()` instead of `mutate()`:

```{r, eval=F}
transmute(presidential, 
    duration_days=end - start)
```

Re-assign to a new - or the same - data frame/tibble using the R **assignment operator: <-**

```{r, eval=T}
presidential <- mutate(presidential, 
                duration_days=end - start)
```

* If you want to change the name of a column, you can use the function `rename`:

```{r, eval=T}
# by the name
rename(presidential, President=name)

# or the index
rename(presidential, President=1)

# you can rename several columns
rename(presidential, President=name, Political_party=party)
```


## select

`select` will select (and optionally rename) columns/variables in a data frame / tibble.

Select column **name** only from the `presidential` data set:

```{r, highlight=c(1,3), echo=F, warning=F,message=F}
library(kableExtra)
knitr::kable(presidential) %>% 
  kable_styling(bootstrap_options = "striped", font_size = 14) %>% 
  column_spec(1, background = "yellow")
```

```{r, eval=T}
select(presidential, name)
```

Select 2 columns: **party** and **name** (in that order):

```{r, eval=F}
select(presidential, 
       party, name)
```

Rename a column as you select it:
```{r, eval=T}
select(presidential, 
       party, President=name)
```

Select all columns **except** party with the **-** sign:
```{r, eval=T}
select(presidential, 
       -party)
```

Select all columns between **start** and **party** (with both included)
```{r, eval=T}
 select(presidential, 
        start:party)
```

### select_if

Select only columns containing characters with **select_if()**:

```{r, eval=T, echo =T}
select_if(presidential, 
    is.character)
```

Select only columns containing a **date**:

```{r, eval=F, echo =FALSE}
select_if(presidential, 
          function(x)inherits(x, 'Date'))
```

<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>

For the next hands-on, we will use th `starwars` dataset: it contains information about the Star Wars movie characters.

* Create a new column **BMI** that contains the **BMI** of each character (Body Mass Index, calculated as `weight in kg / height in m`: we will assume that the `height` column is expressed as **cm** and the `mass` column is expressed as **kg**)
* Rename column `name` to `character_name`.
* Remove column `vehicles` and `starships`.
* Save the changes to a new tibble `starwarsBMI`.

<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r, eval=FALSE}
# Create a new column BMI that contains the BMI of each character
mutate(starwars, BMI=mass/(height*0.01)^2)

# Rename column name to character_name.
rename(starwars, character_name=name)

# Remove column `vehicles` and `starships`.
select(starwars, -c(vehicles, starships))

# Save all the changes to a new tibble starwarsBMI (use the %>% operator)
starwarsBMI <- starwars %>% 
  mutate(BMI=mass/(height*0.01)^2) %>% 
  select(-c(vehicles, starships)) %>%
  rename(character_name=name)
```

</details>


## filter

`filter()` is used to filter rows in a data frame / tibble.

Keep rows if party is **Democratic**:

```{r, highlight=c(1,3), echo=F, warning=F,message=F}
knitr::kable(presidential) %>% 
  kable_styling(bootstrap_options = "striped", font_size = 14) %>% 
  row_spec(c(2:3, 6, 9, 11), background = "yellow")
```

```{r, eval=T}
 filter(presidential, 
        party=="Democratic")
```

You can filter using several variables/columns:
```{r, eval=F}
filter(presidential, 
       party=="Republican", name=="Bush")

# This implicity uses the "&", i.e. the fact that both conditions have to be TRUE
filter(presidential, 
       party=="Republican" & name=="Bush")

# Any logical operators can be used
filter(presidential, 
       name %in% c("Bush", "Kennedy"))
```

<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>


## summarise & group_by
 
`summarise` collapses a data frame to a single row (base R: **aggregate()**)
 
Get average length of terms:

```{r, eval=T}
summarise(presidential, 
          mean(duration_days))
```

Get average length of terms + count of the total of entries:

```{r, eval=T}
summarise(presidential,
          mean(duration_days), 
          n())
```

You can also give a name to each of the calculations you produce with `summarise` (and add more calculations!):

```{r, eval=T}
summarise(presidential,
          mean_term=mean(duration_days), 
          min_term=min(duration_days),
          max_term=max(duration_days),
          count_presidents=n())
```

You can combine `summarise` with `group_by` to get, for example, the number of presidents per political party:

* `group_by` defines a grouping based on existing variables.
* `summarise` then processes the command based on the grouping

```{r}
groups <- group_by(presidential,
                   party)
summarise(groups, 
          n())

# One line, using the %>% operator:
group_by(presidential, party) %>% 
  summarise(n())
```

> Note: the row above is equivalent to using `count` (a wrapper): `count(presidential, party)`

```{r}
count(presidential, party)
```

You can use the same structure to calculate **the average length of terms per political party**:

```{r}
group_by(presidential, party) %>% 
  summarise(mean(duration_days))
```


<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>

starwars %>% group_by(gender, eye_color) %>% summarise(mycounts=n()) %>% arrange(desc(mycounts))


## arrange

`arrange` orders the rows of a data frame by the values of selected columns.
<br>
Let's order rows by increasing mandate duration:

```{r, eval=T}
arrange(presidential, duration_days)
# decreasing order: arrange(presidential2, desc(duration_days))
```

You can use several columns for the sorting
```{r, eval=T}
arrange(presidential, 
        duration_days, name)
```

If a grouping was done before, you can arrange first by grouping and then by selected variable(s) setting the `.by_group=TRUE` parameter:

```
mutate(presidential, duration_days=end-start) %>%
    group_by(party) %>% 
    arrange(duration_days, .by_group=TRUE)
```
    
<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>



## More useful functions from `dplyr`

nth(): extract the nth value of a vector

presidential %>% nth(name, 4)

extract a single column:

presidential %>% pull(name)
presidential %>% pull(duration_days, name=name)

subset rows using their positions:

presidential %>% slice(4)

join (left, right etc.) functions

count(presidential, party) 




## Exercise

We will work with the **storms** data set: positions and attributes of **198 tropical storms**, measured every 6 hours.

1. Remove columns **month**, **day**, **hour**, **lat**, **long**, **ts_diameter** and **hu_diameter**.
2. Calculate the **median pressure for each storm status**.
3. Calculate the **minimum wind speed for each storm (name)**.
  * What storm has the minimum wind speed?
4. Calculate **how many storms happened each year**.
  * *TIP: find what* `distinct()` *from* the `dplyr` package can do...
  * What are the years with the **maximum** number of storms?


<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r, eval=F}
# 1. Remove columns month, day, hour, lat, long, ts_diameter and hu_diameter.
  # remove columns
  select(storms, -lat, -long, -ts_diameter, -hu_diameter)
  # same as:
  select(storms, -c(lat, long, ts_diameter, hu_diameter))
```


```{r}
# 2. Calculate the median pressure for each storm status.
  # group by status and calculate median pressure per storm status
select(storms, -lat, -long, -ts_diameter, -hu_diameter) %>% 
  group_by(status) %>%
  summarise(median(pressure))
```


```{r, eval=F}
# 3. Calculate the minimum wind speed for each storm (name).  
  # group storms by name and calculate minimum wind speed
storms %>%
  group_by(name) %>%
  summarise(min_wind = min(wind))
  # what storm(s) has/have the smallest minimum wind speed?
storms %>%
  group_by(name) %>%
  summarise(min_wind = min(wind)) %>% 
  slice_min(min_wind)
```

```{r, eval=F}
# 4. Calculate how many storms happened each year.
  # get unique rows when considering both name and year columns
distinct(storms, name, year)
  # group by year and count the number of storms
distinct(storms, name, year) %>%
  group_by(year) %>%
  summarise(storms_per_year=n())
    # What are the years with the **maximum** number of storms?
distinct(storms, name, year) %>%
  group_by(year) %>%
  summarise(storms_per_year=n()) %>%
  arrange(desc(storms_per_year)) %>% 
  head()
```



