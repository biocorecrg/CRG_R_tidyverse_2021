# Data manipulation

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE)
```

Package `dplyr` introduces a grammar of data manipulation. See the nice [cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf)
<br>

We will first introduce the **5 intuitively-named key functions** from **{dplyr}**:
<br>

```{r, echo=FALSE, eval=TRUE}
knitr::kable(
  data.frame(name=c("**`mutate`**", "**`select`**", "**`filter`**", "`summarise`", "`arrange`"), 
             `what it does`=c("adds new variables (columns) that are functions of existing variables", "picks variables (columns) based on their names.", "picks observations (rows) based on their values.", "collapses multiple values down to a single summary.", "changes the ordering of the rows.")), caption = 'the 5 core `dplyr` functions',
  format = "html", table.attr = "style='width:90%;'"
)
```

<br>

All 5 functions work in a similar and consistent way:

* The first argument is the input: a `data frame` or a `tibble`.
* The output is a new `tibble`.
 
> *Note that {dplyr} never modifies the input: you need to* ***redirect the output*** *and save in a new - or the same - object.*

<br><br> 
We will use the `presidential` data set from the `ggplot2` package.
*It contains data of the terms of* ***presidents of the USA***, *from Eisenhower to Obama:*

* Name
* Term starting date
* Term ending date of mandate
* Political party
 
```{r, echo=F, warning=F, message=F}
library(kableExtra)
knitr::kable(ggplot2::presidential, caption="`presidential` data set")
```


## mutate & transmute

`mutate` allows to create new columns that are functions of the existing ones.

* Create a new column with the duration of each term:

```{r, eval=FALSE}
# Subtracting column start to column end
mutate(presidential, 
    duration_days=end-start)
```

> *Notes:*

> * Use **unquoted** column names.
> * Columns are added at the end of the data frame.
> * `mutate` keeps all columns. 

<br>
If you want to keep **only the newly created column(s)** (drop the remaining ones): use `transmute()` instead of `mutate()`:

```{r, eval=F}
transmute(presidential, 
    duration_days=end - start)
```

Re-assign to a new - or the same - data frame/tibble using the **usual R assignment operator: <-**

```{r, eval=T}
presidential2 <- mutate(presidential, 
                duration_days=end - start)
```

* If you want to change the name of a column, you can use the function `rename`:

```{r, eval=F}
# using the column name:
rename(presidential2, 
       President=name)

# or the column index:
rename(presidential2, 
       President=1)

# you can rename several columns using the same command:
rename(presidential2, 
       President=name, 
       Political_party=party)
```


## select

`select` will select (and optionally rename) columns/variables in a data frame / tibble.

Select column **"name"** only from the `presidential2` object:

```{r, highlight=c(1,3), echo=F, warning=F,message=F}
library(kableExtra)
knitr::kable(presidential2) %>% 
  kable_styling(bootstrap_options = "striped", font_size = 14) %>% 
  column_spec(1, background = "yellow")
```

```{r, eval=F}
select(presidential2, 
       name)
```

Select 2 columns: **party** and **name** (in that order):

```{r, eval=F}
select(presidential2, 
       party, name)
```

Rename a column as you select it:
```{r, eval=F}
select(presidential2, 
       party, President=name)
```

Select all columns **except** party with the **-** sign:
```{r, eval=F}
select(presidential2, 
       -party)
```

Select all columns between **start** and **party** (with both columns included)
```{r, eval=T}
 select(presidential2, 
        start:party)
```

### select_if

Select only columns containing characters with **select_if()**:

```{r, eval=T, echo =T}
# select columns containing characters:
select_if(presidential2, 
    is.character)
```

Select only columns containing a **date** with the `is.Date` function from the `lubridate` package:

```{r, eval=TRUE, echo=TRUE}
select_if(presidential2, 
      lubridate::is.Date)
```

<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>

For the next hands-on, we will use th `starwars` dataset: it contains information about the Star Wars movie characters:

```{r, echo=F, warning=F,message=F}
library(kableExtra)
knitr::kable(starwars[1:5,1:9]) %>% 
  kable_styling(bootstrap_options = "striped", font_size = 14)
```


* Create a new column **BMI** that contains the **BMI** of each character (Body Mass Index, calculated as `weight in kg / (height in m)^2`: we will assume that the `height` column is expressed as **cm** and the `mass` column is expressed as **kg**)
* Rename column `name` to `character_name`.
* Remove columns `vehicles` and `starships`.
* Save all the changes into the new tibble `starwarsBMI` (use the `%>%` !).

<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r, eval=FALSE}
# Create a new column BMI that contains the BMI of each character
mutate(starwars, BMI=mass/(height*0.01)^2)

# Rename column name to character_name.
rename(starwars, character_name=name)

# Remove columns `vehicles` and `starships`.
select(starwars, -c(vehicles, starships))

# Save all the changes into the new tibble starwarsBMI (use the %>% operator)
starwarsBMI <- starwars %>% 
  mutate(BMI=mass/(height*0.01)^2) %>% 
  select(-c(vehicles, starships)) %>%
  rename(character_name=name)
```

</details>

### select using patterns

Some [select helpers](https://tidyselect.r-lib.org/reference/starts_with.html) are available, that help you select columns given certain **patterns** in their names:

```{r, echo=FALSE, eval=TRUE}
knitr::kable(
  data.frame(name=c("starts_with", "ends_with", "contains", "matches", "num_range()"), 
             description=c("starts with a prefix", "ends with a suffix", "contains a literal string", "matches a regular expression", "matches a numerical range like x01, x02, x03")), caption = 'select helpers',
  format = "html", table.attr = "style='width:60%;'"
)
```

<br>
For example, select only columns from the `starwars` dataset which name **end with** "color":

```{r}
select(starwars,
       ends_with("color"))
```

Or which start with the letter **h**:

```{r}
select(starwars,
       starts_with("h"))
```

If you are familiar with **regular expressions**, you can also use them within the `matches` function:

```{r}
select(starwars,
       matches("^h")) # same as starts_with
```

Finally, you can select columns which name match a **numerical range** with `num_range`.
<br>
For example, let's take the `billboard` dataset that contains column names wk1, wk2, wk3 ... up to wk76, and select only columns from wk18 to wk22:

```{r}
select(billboard,
       num_range("wk", 18:22))
```

## filter

`filter()` is used to filter rows in a data frame / tibble.

Keep rows if **Democratic** is found in column `party`:

```{r, highlight=c(1,3), echo=F, warning=F,message=F}
knitr::kable(presidential) %>% 
  kable_styling(bootstrap_options = "striped", font_size = 14) %>% 
  row_spec(c(2:3, 6, 9, 11), background = "yellow")
```

```{r, eval=T}
 filter(presidential, 
        party=="Democratic")
```

You can filter using several variables/columns:
```{r, eval=F}
filter(presidential, 
       party=="Republican", name=="Bush")

# This implicity uses the "&", i.e. the fact that both conditions have to be TRUE
filter(presidential, 
       party=="Republican" & name=="Bush")

# Any logical operators can be used
filter(presidential, 
       name %in% c("Bush", "Kennedy"))
```

The same can be used for numerical values: let's select all rows from `table5` where `century > 19`:

```{r}
filter(table5,
       century > 19)
```

<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>

Going back to our previously create starwarsBMI data frame:

* How many characters have a **BMI** > 30?
* How many characters have a **BMI** > 30 <u>AND</u> are **Droids** ("Droid" in column `species`)?
* From the previous selection (BMI > 30 and Droid), select columns BMI, character_name, height and mass, and save in the new object `DroidBMI30`.

<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r, eval=F}
# How many characters have a BMI > 30?
filter(starwarsBMI, BMI > 30)

# How many characters have a BMI > 30 AND are Droids ("Droid" in column "species")?
filter(starwarsBMI, BMI > 30 & species=="Droid")
  
# From the previous selection (BMI > 30 and Droid), select columns BMI, character_name, height and mass, and save in the new object DroidBMI30.
DroidBMI30 <- starwarsBMI %>% 
            filter(BMI > 30 & species=="Droid") %>% 
            select(BMI, character_name, height, mass)
```

</details>

## summarise & group_by
 
`summarise` collapses a data frame to a **1-row tibble** (base R equivalent of **aggregate()**)
 
Get average length of terms:

```{r, eval=T}
summarise(presidential2, 
          mean(duration_days))
```

Get average length of terms + count of the total of entries:

```{r, eval=T}
summarise(presidential2,
          mean(duration_days), 
          n())
```

You can also give a name to each of the calculations you produce with `summarise` (and add more calculations!):

```{r, eval=T}
summarise(presidential2,
          mean_term=mean(duration_days), 
          min_term=min(duration_days),
          max_term=max(duration_days),
          count_presidents=n())
```

You can combine `summarise` with `group_by` to get, for example, the number of presidents per political party:

* `group_by` defines a grouping based on existing variables.
* `summarise` then processes the command based on the grouping

```{r}
# group based on the "party" column (that contains "Democratic" or "Republican")
groups <- group_by(presidential2,
                   party)

# count the number of presidents per party:
summarise(groups, 
          n())

# One line, using the %>% operator:
group_by(presidential2, party) %>% 
      summarise(n())
```

> Note: the row above is equivalent to using `count` (a wrapper): `count(presidential, party)`

```{r}
count(presidential2, party)
```

You can use the same structure to calculate **the average length of terms per political party**:

```{r}
group_by(presidential2, party) %>% 
  summarise(mean(duration_days))
```


<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>

Back to our `starwarsBMI` tibble:

* Count the number of occurrences of each `hair color` per `gender`.
* Count the average BMI per `species`. Add a count of the number of individuals per species.

<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r, eval=F}
# Count the number of occurrences of each `hair color` per `gender`
starwarsBMI %>% 
  group_by(gender, hair_color) %>% 
  summarise(mycounts=n())

# Count the average **BMI** per `species`.  Add a count of the number of individuals per species.
starwarsBMI %>% 
  group_by(species) %>% 
  summarise(average_bmi=mean(BMI, na.rm=TRUE), count_individuals=n())
```

</details>

## arrange

`arrange` orders the rows of a data frame **by the values of selected columns**.
<br>
Let's order rows by increasing mandate duration:

```{r, eval=T}
arrange(presidential2, duration_days)
# decreasing order with arrange(presidential2, desc(duration_days))
```

You can use several columns for the sorting
```{r, eval=T}
arrange(presidential2, 
        duration_days, name)
```

If a grouping was done before, you can arrange first by grouping and then by selected variable(s) setting the `.by_group=TRUE` parameter:

```{r}
mutate(presidential2, duration_days=end-start) %>%
    group_by(party) %>% 
    arrange(duration_days, .by_group=TRUE)
```
    
<center><h4 style="background-color: #a4edff; display: inline-block;">**HANDS-ON**</h4></center>

Go back to the previous exercise: "count the average **BMI** per `species`.  Add a count of the number of individuals per species." (on the `starwarsBMI` data set):

```{r, eval=FALSE}
starwarsBMI %>% 
  group_by(species) %>% 
  summarise(average_bmi=mean(BMI, na.rm=TRUE), count_individuals=n())
```

* Keep only species that have **2 or more individuals**.
* Arrange by decreasing **average BMI**.

<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r, eval=F}
starwarsBMI %>% 
  group_by(species) %>% 
  summarise(average_bmi=mean(BMI, na.rm=TRUE), count_individuals=n()) %>%
  filter(count_individuals >= 2) %>%
  arrange(desc(average_bmi))
```

</details>

## A few more useful functions from `dplyr`

* Extract rows with `slice`:

```{r, eval=F}
# Fetch the first 2 rows
slice(presidential2, 1:2)
```

* Extract a single column as a vector with `pull`:

```{r, eval=F}
# extract column "duration_days"
presidential2 %>% pull(duration_days)

# extract column "duration_days" as a vector, and name the vector using the "name" column
presidential2 %>% pull(duration_days, name=name)
```

```{r, eval=F}
```

```{r, eval=F}
```


## Exercise

We will work with the **storms** data set: positions and attributes of **198 tropical storms**, measured every 6 hours.

1. Remove columns **month**, **day**, **hour**, **lat**, **long**, **ts_diameter** and **hu_diameter**.
2. Calculate the **median pressure for each storm status**.
3. Calculate the **minimum wind speed for each storm (name)**.
  * What storm has the minimum wind speed?
4. Calculate **how many storms happened each year**.
  * *TIP: find what* `distinct()` *from* the `dplyr` package can do...
  * What are the years with the **maximum** number of storms?


<details>
<summary>
<h5 style="background-color: #a4edff; display: inline-block;">*Answer*</h5>
</summary>

```{r, eval=F}
# 1. Remove columns month, day, hour, lat, long, ts_diameter and hu_diameter.
  # remove columns
  select(storms, -lat, -long, -ts_diameter, -hu_diameter)
  # same as:
  select(storms, -c(lat, long, ts_diameter, hu_diameter))
```


```{r}
# 2. Calculate the median pressure for each storm status.
  # group by status and calculate median pressure per storm status
select(storms, -lat, -long, -ts_diameter, -hu_diameter) %>% 
  group_by(status) %>%
  summarise(median(pressure))
```


```{r, eval=F}
# 3. Calculate the minimum wind speed for each storm (name).  
  # group storms by name and calculate minimum wind speed
storms %>%
  group_by(name) %>%
  summarise(min_wind = min(wind))
  # what storm(s) has/have the smallest minimum wind speed?
storms %>%
  group_by(name) %>%
  summarise(min_wind = min(wind)) %>% 
  slice_min(min_wind)
```

```{r, eval=F}
# 4. Calculate how many storms happened each year.
  # get unique rows when considering both name and year columns
distinct(storms, name, year)
  # group by year and count the number of storms
distinct(storms, name, year) %>%
  group_by(year) %>%
  summarise(storms_per_year=n())
    # What are the years with the **maximum** number of storms?
distinct(storms, name, year) %>%
  group_by(year) %>%
  summarise(storms_per_year=n()) %>%
  arrange(desc(storms_per_year)) %>% 
  head()
```



